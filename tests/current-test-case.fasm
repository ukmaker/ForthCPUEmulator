
#SYSTEM:   0x0000 ; System reset vector
#RAMSTART: 0x2000 ; Dictionary grows from here
#VARSTART: 0x3000 ; Variables grow up from here
#SPTOP:    0x3800 ; Data stack pointer grows down from here
#RSTOP:    0x3ffe ; And the return stack from here
                  ; This gives both stacks 2K bytes
#LBUF_LEN: 80     ; Maximum length of the line buffer in chars
#BASE_DEC: 10
#BASE_HEX: 16
#BASE_BIN: 2

#UART_STATUS_REG:                   0xffe0
#UART_DATA_REG:                     0xffe2
#UART_RX_DIV_REG:                   0xffe4
#UART_TX_DIV_REG:                   0xffe6
#UART_STATUS_BIT_RX_DATA_AVAILABLE: 0x0001
#UART_STATUS_BIT_TX_ACTIVE:         0x0002
#UART_STATUS_BIT_TX_DONE:           0x0004
#UART_STATUS_BIT_TX_INT:            0x0008
#UART_STATUS_BIT_RX_INT:            0x0010

.ORG #VARSTART
%BASE: 2               ; Current system numeric base
%LBUF_IDX: 2           ; Current line buffer byte pointer
%LBUF_END: 2           ; Address of the last character in the buffer
%LBUF_DATA: #LBUF_LEN  ; Line buffer data
%DICTIONARY_POINTER: 2
%CONTEXT: 2
%CURRENT: 2
%CORE: 2
%MODE: 2
%STATE: 2
%FENCE: 2
%TOKEN_HANDLER: 2      ; User-installable vector for a word to handle unknown tokens
%USER_TOP: 2
USER_VARS:
.DATA 0


.ORG #SYSTEM ; Start vector is at address 0
START:
    JPI COLD

INT0:
    JPI INT0_HANDLER
INT1:
    JPI INT1_HANDLER

INT0_HANDLER:
INT1_HANDLER:
    HALT



SYSCALL_UART_RX_BYTE:
    ;  Return byte in RA
    .ALIAS R1,UART_STATUS_REG
    .ALIAS R2,UART_DATA_REG
    PUSH R1,RS
    PUSH R2,RS
    LDI UART_STATUS_REG,#UART_STATUS_REG
    LDI UART_DATA_REG,#UART_DATA_REG

_SYSCALL_UART_RX_BYTE_WAIT_READY:
    LD RA,UART_STATUS_REG
    ANDAI #UART_STATUS_BIT_RX_DATA_AVAILABLE
    JRI[Z] _SYSCALL_UART_RX_BYTE_WAIT_READY
    LD RA,UART_DATA_REG
    POP R2,RS
    POP R1,RS
    JP RL

SYSCALL_UART_READLINE:
    ; ( bufaddr buflen -- status )
    ; status = 0 : no data was available
    ; status = 1 : data available
    ; status = 2 : empty input
    ; status = 3 : Ctl-C received during input
    .ALIAS R0,UART_STATUS_REG
    .ALIAS R1,UART_DATA_REG
    .ALIAS R2,BUFPTR
    .ALIAS R3,BUFLEN
    .ALIAS R4,BUFEND
    .ALIAS R5,RECEIVED
    .ALIAS R6,STATUS
    .ALIAS R7,BUFIDX

    PUSH R0,RS
    PUSH R1,RS
    PUSH R2,RS
    PUSH R3,RS
    PUSH R4,RS
    PUSH R5,RS
    PUSH R6,RS
    PUSH R7,RS
    PUSH RA,RS

    POP BUFLEN,SP           ; Length of the buffer
    POP BUFPTR,SP
    MOV BUFIDX,BUFPTR
    MOV BUFEND,BUFPTR
    ADDI BUFEND,2            ; Points to the location containing the address of the end of the buffer
    ADDI BUFPTR,4          ; Where the actual characters are in the buffer
    ST  BUFPTR,BUFIDX
    MOVI RECEIVED,0

    LDI UART_STATUS_REG,#UART_STATUS_REG
    LDI UART_DATA_REG,#UART_DATA_REG  

    LD RA,UART_STATUS_REG
    ANDAI #UART_STATUS_BIT_RX_DATA_AVAILABLE
    JRI[Z] _SYSCALL_UART_READLINE_NONE

_SYSCALL_UART_READLINE_LOOP:
    LD RA,UART_DATA_REG
    CMPAI 0x03 ; Ctl-C?
    JRI[Z] _SYSCALL_UART_READLINE_CTLC 

    CMPAI 0x0a ; CR?
    JRI[Z] _SYSCALL_UART_READLINE_READ 

    PUSHR_B RA,BUFPTR
    ADDI RECEIVED,1
    SUBI BUFLEN,1
    JRI[Z] _SYSCALL_UART_READLINE_DONE

_SYSCALL_UART_READLINE_WAIT:
    LD RA,UART_STATUS_REG
    ANDAI #UART_STATUS_BIT_RX_DATA_AVAILABLE
    JRI[Z] _SYSCALL_UART_READLINE_WAIT
    JRI _SYSCALL_UART_READLINE_LOOP

_SYSCALL_UART_READLINE_READ:
    ; Did we actually read something?
    CMPI RECEIVED,0
    JRI[Z] _SYSCALL_UART_READLINE_NONE
    ; Store the end of the received data to BUFPTR
    ST BUFPTR,BUFEND
    MOVI STATUS,1
    JRI _SYSCALL_UART_READLINE_DONE

_SYSCALL_UART_READLINE_NONE:
    MOVI STATUS,0
    JRI _SYSCALL_UART_READLINE_DONE

_SYSCALL_UART_READLINE_CTLC:
    MOVI STATUS,0x03

_SYSCALL_UART_READLINE_DONE:
    PUSH STATUS,SP
    POP RA,RS
    POP R7,RS
    POP R6,RS
    POP R5,RS
    POP R4,RS
    POP R3,RS
    POP R2,RS
    POP R1,RS
    POP R0,RS
    JP RL


COLD:
    ; Test the number conversion routine
  LDI SP,#SPTOP
  LDI RS,#RSTOP

  JRIL SYSCALL_UART_RX_BYTE

  LDI R0,%LBUF_IDX
  LDI R1,32
  PUSH R0,SP
  PUSH R1,SP

  JRIL SYSCALL_UART_READLINE


  HALT

  ; Should return an error for an empty string
  LDI RA,NUM_BIN_166   ; 
  PUSH RA,SP
  JRIL SYSCALL_NUMBER
  POP RA,SP
  POP RB,SP
  HALT

NUM_0xaf:      .DATA  4 .SDATA "0xaf"
NUM_MINUS_99:  .DATA  3 .SDATA "-99"
NUM_BIN_166:   .DATA 10 .SDATA "0b10100110"
C_TO_I:
    ; Attempt to convert the hex char in RA to a valid number
    ; Return the number in RA, or -1 if no converted
    ; Only affects RA
    CMPAI '0'
    JRI[C] C_TO_I_INVALID
    SUBAI '0'
    CMPAI 10
    JRI[NC] C_TO_I_GT_9
    JP RL ; return the value
C_TO_I_GT_9:
    SUBAI 7 ; Put A at 10
    CMPAI 10
    JRI[C] C_TO_I_INVALID ; less than 'A'
    CMPAI 16
    JRI[NC] C_TO_I_LOWER_CASE ; greater than 'F'
    JP RL ; return value
C_TO_I_LOWER_CASE:
    SUBAI 32
    CMPAI 10
    JRI[C] C_TO_I_INVALID
    CMPAI 16
    JRI[NC] C_TO_I_INVALID
    JP RL
C_TO_I_INVALID:
    MOVAS -1
    JP RL


SYSCALL_NUMBER:
  ; Convert the token at the current DP to a number
  ; Ignores the system BASE. Expects the number base to be specified
  ; <no prefix> - decimal
  ; 0x          - hex
  ; 0b          - binary
  ; a character literal may be represented
  ;   'c'      - the trailing ' is not optional as in GForth
  ;   '\n'     - backslashes are allowed for \n, \t, \r and \0
  ;
  ; ( dp -- number true ) | ( dp -- false )
  .ALIAS R0,DP
  .ALIAS R1,NUM
  .ALIAS R2,BASE
  .ALIAS RA,CHAR
  .ALIAS R4,LEN
  .ALIAS R5,SIGN
  .ALIAS R6,TMP
    
  PUSH RL,RS
  POP DP,SP
  LD LEN,DP
  ; Actually got something to parse?
  CMPI LEN,0
  JRI[Z] SYSCALL_NUMBER_FAILED
  ; Yes we do
  ADDI DP,2
  MOVI NUM,0
  MOVI SIGN,0 ; Positive
  ; Length of 1 means it must be parsed as decimal
  LD_B CHAR,DP
  CMPI LEN,1
  JRI[Z] SYSCALL_NUMBER_DECIMAL
  ; Longer than 1
  ; Is the first char a minus sign?
  ; Is so, must be decimal
  CMPAI '-'
  JRI[NZ] SYSCALL_NUMBER_NOT_NEGATIVE
  MOVI SIGN,1
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  JRI SYSCALL_NUMBER_DECIMAL
SYSCALL_NUMBER_NOT_NEGATIVE:
  CMPAI '\''
  JRI[NZ] SYSCALL_NUMBER_NOT_LITERAL
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  JRI SYSCALL_NUMBER_LITERAL
SYSCALL_NUMBER_NOT_LITERAL:
  ; First char a '0' in which case check for a base
  CMPAI '0'
  JRI[NZ] SYSCALL_NUMBER_DECIMAL
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  ; check for valid bases (x or b)
  LDI TMP,'x'
  CMP CHAR,TMP
  JRI[NZ] SYSCALL_NUMBER_NOT_HEX
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  JRI SYSCALL_NUMBER_HEX
SYSCALL_NUMBER_NOT_HEX:
  LDI TMP,'b'
  CMP CHAR,TMP
  JRI[NZ] SYSCALL_NUMBER_DECIMAL
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  JRI SYSCALL_NUMBER_BIN
SYSCALL_NUMBER_DECIMAL:
  ; We got here! It should be a decimal number
  MOVI BASE,10
  JRI SYSCALL_NUMBER_CONVERT
SYSCALL_NUMBER_BIN:
  MOVI BASE,2
  JRI SYSCALL_NUMBER_CONVERT
SYSCALL_NUMBER_HEX:
  LDI BASE,16

SYSCALL_NUMBER_CONVERT:
  ; Current char to convert in CHAR, remaining length in LEN
  MUL NUM,BASE
  LD_B CHAR,DP
  JRIL C_TO_I
  ; If the return value is negative, then the conversion failed
  BITI RA,15
  JRI[NZ] SYSCALL_NUMBER_FAILED
  MOV RB,RA
  CMP BASE,RB
  JRI[C] SYSCALL_NUMBER_FAILED ; > BASE
  JRI[Z] SYSCALL_NUMBER_FAILED ; or == BASE
  ADD NUM,CHAR
  ADDI DP,1
  SUBI LEN,1
  JRI[NZ] SYSCALL_NUMBER_CONVERT
  ; We're done
SYSCALL_NUMBER_DONE:
  CMPI SIGN,1
  JRI[NZ] SYSCALL_NUMBER_RESULT
  MOVI TMP,0
  SUB TMP,NUM
  MOV NUM,TMP
SYSCALL_NUMBER_RESULT:  
  PUSH NUM,SP
  MOVI R0,1
  PUSH R0,SP
  POP RL,RS
  JP RL

SYSCALL_NUMBER_LITERAL:
  ; Allow for the following backslashed characters
  ; \0
  ; \n
  ; \t
  ; \r
  ; \\
  ; All other chars are converted directly
  LD_B CHAR,DP
  CMPAI '\\'
  JRI[NZ] SYSCALL_NUMBER_NOT_BACKSLASH
  ADDI DP,1
  SUBI LEN,1
  JRI[Z] SYSCALL_NUMBER_FAILED ; nothing left to convert
  ; Ok what was backslashed?
  CMPAI '\\'
  JRI[NZ] SYSCALL_NUMBER_NOT_BACKSLASH
  LDI NUM,'\\'
  JRI SYSCALL_NUMBER_LITERAL_LAST
  CMPAI '0'
  JRI[NZ] SYSCALL_NUMBER_NOT_ZERO
  MOVI NUM,0
  JRI SYSCALL_NUMBER_LITERAL_LAST
SYSCALL_NUMBER_NOT_ZERO:  
  CMPAI 'n'
  JRI[NZ] SYSCALL_NUMBER_NOT_N
  LDI NUM,'\n'
  JRI SYSCALL_NUMBER_LITERAL_LAST
SYSCALL_NUMBER_NOT_N:
  CMPAI 't'
  JRI[NZ] SYSCALL_NUMBER_NOT_T
  LDI NUM,'\t'
  JRI SYSCALL_NUMBER_LITERAL_LAST
SYSCALL_NUMBER_NOT_T:
  CMPAI 'r'
  JRI[NZ] SYSCALL_NUMBER_NOT_BACKSLASH
  LDI NUM,'\r'
  JRI SYSCALL_NUMBER_LITERAL_LAST

SYSCALL_NUMBER_NOT_BACKSLASH:
  ; Just grab the char at the DP
  LD NUM,DP

SYSCALL_NUMBER_LITERAL_LAST:
  ; Does it end with a single quote?
  ; if not we have a problem
  ADDI DP,1
  SUBI LEN,1
  LD_B RA,DP
  CMPAI '\''
  JRI[NZ] SYSCALL_NUMBER_FAILED
  SUBI LEN,1
  ; There should be nothing left
  JRI[NZ] SYSCALL_NUMBER_FAILED
  ; We're good
  JRI SYSCALL_NUMBER_DONE

SYSCALL_NUMBER_FAILED:
  MOVI R0,0
  PUSH R0,SP
  POP RL,RS
  JP RL


