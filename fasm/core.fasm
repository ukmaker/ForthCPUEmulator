; The core of the system is written in assembler for speed
; You can link devices from Arduino-land by writing a word
; which uses a SYSCALL instruction to call a function you
; supply in C to wrap the Ardino library
;
; Memory Map
; You should redefine this for your device depending on how
; much memory you have available.
; E.g. for an Atmega 328P (32KROM, 2K RAM) With no other code the Arduino environment
; needs approx 900 bytes RAM - so we take only 1K for Forth
;   #RAMSTART: 0x2000  ; Need to allocate 8K for Forth ROM
;   #VARSTART: 0x2200  ; Allow 256 bytes for new Forth words in RAM. Allot 64 bytes for variables. 128 for LBUF (see below)
;   #SPTOP:    0x23e0  ; Vars end at 0x2500 - 16 bytes for the data stack
;   #RSTOP:    0x23fe  ; 16 bytes for the return stack 
;
; values below are for STM32F401
;
#SYSTEM:   0x0000 ; System reset vector
#RAMSTART: 0x2000 ; Dictionary grows from here
#VARSTART: 0x3000 ; Variables grow up from here
#SPTOP:    0x3800 ; Data stack pointer grows down from here
#RSTOP:    0x3ffe ; And the return stack from here
                  ; This gives both stacks 2K bytes
#LBUF_LEN: 80     ; Maximum length of the line buffer in chars
#BASE_DEC: 10
#BASE_HEX: 16
#BASE_BIN: 2

#MODE_EXECUTE: 0
#MODE_COMPILE: 1
#STATE_NOT_FOUND: 0
#STATE_FOUND: 1

#HEADER_MASK: 0x00ff
#HEADER_HEADER_BIT: 15
#HEADER_SCOPE_BITS: 12
#HEADER_PASSIVE:     0x8000 ; 0b1000 0000 0000 0000 - Normal word    execute/compile
#HEADER_IMMEDIATE:   0x9000 ; 0b1001 0000 0000 0000 - Immediate word error/execute
#HEADER_RUNTIME:     0xa000 ; 0b1010 0000 0000 0000 - Runtime word   execute/error (e.g. ':')
#HEADER_EXECUTIVE:   0xb000 ; 0b1011 0000 0000 0000 - Executive word execute/execute (e.g '(' ))
#HEADER_COMPILETIME: 0xc000 ; 0b1100 0000 0000 0000 - Compiled word  error/compile
#HEADER_HAS_LOCALS:  0x0800 ; 0b1000 1000 0000 0000 - This word allocates local variables


#UART_STATUS_REG:                   0xffe0
#UART_DATA_REG:                     0xffe2
#UART_RX_DIV_REG:                   0xffe4
#UART_TX_DIV_REG:                   0xffe6
#UART_STATUS_BIT_RX_DATA_AVAILABLE: 0x0001
#UART_STATUS_BIT_TX_ACTIVE:         0x0002
#UART_STATUS_BIT_TX_DONE:           0x0004
#UART_STATUS_BIT_TX_INT:            0x0008
#UART_STATUS_BIT_RX_INT:            0x0010


.ORG #VARSTART
%BASE: 2               ; Current system numeric base
%LBUF_IDX: 2           ; Current line buffer byte pointer
%LBUF_END: 2           ; Address of the last character in the buffer
%LBUF_DATA: #LBUF_LEN  ; Line buffer data
%DICTIONARY_POINTER: 2
%CONTEXT: 2
%CURRENT: 2
%CORE: 2
%MODE: 2
%STATE: 2
%FENCE: 2
%TOKEN_HANDLER: 2      ; User-installable vector for a word to handle unknown tokens
%USER_TOP: 2
USER_VARS:
.DATA 0


.ORG #SYSTEM ; Start vector is at address 0
START:
    JPI COLD

INT0:
    JPI INT0_HANDLER
INT1:
    JPI INT1_HANDLER

INT0_HANDLER:
INT1_HANDLER:
  PUSH R0,SP
  LDI R0,MSG_UNHANDLED_INTERRUPT
  PUSH R0,SP
  JRIL SYSCALL_TYPELN
  POP R0,SP
  RETI

SYSCALLS:

SYSCALL_UART_TX_BYTE:
    ; ( RA=byte )
    .ALIAS R1,UART_STATUS_REG
    .ALIAS R2,UART_DATA_REG
    .ALIAS R0,CHAR

    PUSH CHAR,RS
    MOV CHAR,RA
    LDI UART_STATUS_REG,#UART_STATUS_REG
    LDI UART_DATA_REG,#UART_DATA_REG

_SYSCALL_UART_TX_BYTE_WAIT_READY:
    LD RA,UART_STATUS_REG
    ANDAI #UART_STATUS_BIT_TX_DONE
    JRI[Z] _SYSCALL_UART_TX_BYTE_WAIT_READY

    ST CHAR,UART_DATA_REG
    POP CHAR,RS
    JP RL

SYSCALL_UART_RX_BYTE:
    ;  Return byte in RA
    .ALIAS R1,UART_STATUS_REG
    .ALIAS R2,UART_DATA_REG
    PUSH R1,RS
    PUSH R2,RS
    LDI UART_STATUS_REG,#UART_STATUS_REG
    LDI UART_DATA_REG,#UART_DATA_REG

_SYSCALL_UART_RX_BYTE_WAIT_READY:
    LD RA,UART_STATUS_REG
    ANDAI #UART_STATUS_BIT_RX_DATA_AVAILABLE
    JRI[Z] _SYSCALL_UART_RX_BYTE_WAIT_READY
    LD RA,UART_DATA_REG
    POP R2,RS
    POP R1,RS
    JP RL

SYSCALL_UART_READLINE:
    ; ( bufaddr buflen -- status )
    ; status = 0 : no data was available
    ; status = 1 : data available
    ; status = 2 : empty input
    ; status = 3 : Ctl-C received during input
    .ALIAS R0,UART_STATUS_REG
    .ALIAS R1,UART_DATA_REG
    .ALIAS R2,BUFPTR
    .ALIAS R3,BUFLEN
    .ALIAS R4,BUFEND
    .ALIAS R5,RECEIVED
    .ALIAS R6,STATUS
    .ALIAS R7,BUFIDX

    PUSH R0,RS
    PUSH R1,RS
    PUSH R2,RS
    PUSH R3,RS
    PUSH R4,RS
    PUSH R5,RS
    PUSH R6,RS
    PUSH R7,RS
    PUSH RA,RS

    POP BUFLEN,SP           ; Length of the buffer
    POP BUFPTR,SP
    MOV BUFIDX,BUFPTR
    MOV BUFEND,BUFPTR
    ADDI BUFEND,2            ; Points to the location containing the address of the end of the buffer
    ADDI BUFPTR,4          ; Where the actual characters are in the buffer
    ST  BUFPTR,BUFIDX
    MOVI RECEIVED,0

    LDI UART_STATUS_REG,#UART_STATUS_REG
    LDI UART_DATA_REG,#UART_DATA_REG  

    LD RA,UART_STATUS_REG
    ANDAI #UART_STATUS_BIT_RX_DATA_AVAILABLE
    JRI[Z] _SYSCALL_UART_READLINE_NONE

_SYSCALL_UART_READLINE_LOOP:
    LD RA,UART_DATA_REG
    CMPAI 0x03 ; Ctl-C?
    JRI[Z] _SYSCALL_UART_READLINE_CTLC 

    CMPAI 0x0a ; CR?
    JRI[Z] _SYSCALL_UART_READLINE_READ 

    PUSHR_B RA,BUFPTR
    ADDI RECEIVED,1
    SUBI BUFLEN,1
    JRI[Z] _SYSCALL_UART_READLINE_DONE

_SYSCALL_UART_READLINE_WAIT:
    LD RA,UART_STATUS_REG
    ANDAI #UART_STATUS_BIT_RX_DATA_AVAILABLE
    JRI[Z] _SYSCALL_UART_READLINE_WAIT
    JRI _SYSCALL_UART_READLINE_LOOP

_SYSCALL_UART_READLINE_READ:
    ; Did we actually read something?
    CMPI RECEIVED,0
    JRI[Z] _SYSCALL_UART_READLINE_NONE
    ; Store the end of the received data to BUFPTR
    ST BUFPTR,BUFEND
    MOVI STATUS,1
    JRI _SYSCALL_UART_READLINE_DONE

_SYSCALL_UART_READLINE_NONE:
    MOVI STATUS,0
    JRI _SYSCALL_UART_READLINE_DONE

_SYSCALL_UART_READLINE_CTLC:
    MOVI STATUS,0x03

_SYSCALL_UART_READLINE_DONE:
    PUSH STATUS,SP
    POP RA,RS
    POP R7,RS
    POP R6,RS
    POP R5,RS
    POP R4,RS
    POP R3,RS
    POP R2,RS
    POP R1,RS
    POP R0,RS
    JP RL

SYSCALL_TYPE:
    ; ( addr -- )
    ; Print a FORTH String
    ; Got here from a JL, so preserve RL
    ; TOS SP is the address of the string
    ; First word of the string is the length
    ; Use R0 as the address, R1 as the length, R2 as the char to write
    ; Save to RS to start
    .ALIAS R0,ADDR
    .ALIAS R1,LEN
    .ALIAS RA,CHAR

    PUSH RL,RS
    PUSH R0,RS
    PUSH R1,RS
    PUSH RA,RS

    POP ADDR,SP
    LD LEN,ADDR
    ADDI ADDR,2 ; Point to first char
_SYSCALL_TYPE_LOOP:
    POP_B CHAR,ADDR ; LD_B RA,(R0++)
    PUSH ADDR,RS
    PUSH LEN,RS

    JRIL SYSCALL_UART_TX_BYTE

    POP LEN,RS
    POP ADDR,RS
    SUBI LEN,1
    JRI[NZ] _SYSCALL_TYPE_LOOP

    POP RA,RS
    POP R1,RS
    POP R0,RS
    POP RL,RS
    JP RL

SYSCALL_TYPELN:
    PUSH RL,RS
    JRIL SYSCALL_TYPE
    JRIL SYSCALL_CRET
    POP RL,RS
    JP RL

SYSCALL_CRET:

    PUSH RL,RS

    MOVI RA,0x0d ; CR
    JRIL SYSCALL_UART_TX_BYTE
    
    MOVI RA,0x0a ; LF
    JRIL SYSCALL_UART_TX_BYTE

    POP RL,RS
    JP RL

SYSCALL_DOT:
    ; (val base signed -- )
    .ALIAS R0,VAL
    .ALIAS R1,BASE
    .ALIAS R2,SIGNED
    .ALIAS R3,DIGIT
    .ALIAS R4,IDX
    .ALIAS R5,MASK

    ; Save registers
    PUSH RL,RS
    PUSH R0,RS
    PUSH R1,RS
    PUSH R2,RS
    PUSH R3,RS
    PUSH R4,RS
    PUSH R5,RS

    POP SIGNED,SP
    POP BASE,SP
    POP VAL,SP

    MOV RA,BASE

    CMPAI 2     ; Base 2?
    JRI[Z] _SYSCALL_DOT_BINARY

    CMPAI 0x10  ; Base 16?
    JRI[Z] _SYSCALL_DOT_HEX

    CMPI SIGNED,0 ; Signed?
    JRI[NZ] _SYSCALL_DOT_SIGNED

    ; Print in unsigned decimal
    JRI _SYSCALL_DOT_UNSIGNED

_SYSCALL_DOT_SIGNED:
    ; is the value negative?
    BITI VAL,15
    JRI[Z] _SYSCALL_DOT_UNSIGNED
    ; Yes, so emit a minus sign and make it positive
    PUSH VAL,RS
    LDI RA,'-'
    JRIL SYSCALL_UART_TX_BYTE
    POP DIGIT,RS
    MOVI VAL,0
    SUB VAL,DIGIT ; Make positive

_SYSCALL_DOT_UNSIGNED:
    ; keep dividing by ten and pushing the remainder to the stack until there is nothing left
    ; {R1,R0} contains the input
    ; R2 contains 10
    ; Result is in R0, R1 is remainder
    MOVI DIGIT,0 ; Keep track of the number of digits
_SYSCALL_DOT_UNSIGNED_LOOP:
    MOVI R1,0
    MOVI R2,10

    PUSH DIGIT,RS
    JRIL UD_DIV
    POP DIGIT,RS

    ADDI DIGIT,1
    MOV RA,R1
    ADDAI '0'
    PUSH RA,SP
    CMPI R0,0
    JRI[NZ] _SYSCALL_DOT_UNSIGNED_LOOP
    ; Now print out the digits
_SYSCALL_DOT_UNSIGNED_PRINT_LOOP:
    PUSH DIGIT,RS
    POP RA,SP
    JRIL SYSCALL_UART_TX_BYTE
    POP DIGIT,RS
    SUBI DIGIT,1
    JRI[NZ] _SYSCALL_DOT_UNSIGNED_PRINT_LOOP

    JRI _SYSCALL_DOT_RETURN

; Print in binary
_SYSCALL_DOT_BINARY:
    LDI IDX,0x10
_SYSCALL_DOT_BINARY_LOOP:
    SLI VAL,1
    JRI[C] _SYSCALL_DOT_BINARY_ONE
    PUSH VAL,RS
    PUSH IDX,RS
    MOVAI '0'
    JRI _SYSCALL_DOT_BINARY_TX
_SYSCALL_DOT_BINARY_ONE:
    MOVAI '1'
_SYSCALL_DOT_BINARY_TX:
    JRIL SYSCALL_UART_TX_BYTE
    POP IDX,RS
    POP VAL,RS
    SUBI IDX,1
    JRI[NZ] _SYSCALL_DOT_BINARY_LOOP
    JRI _SYSCALL_DOT_RETURN

_SYSCALL_DOT_HEX:
    LDI IDX,4
_SYSCALL_DOT_HEX_LOOP:
    LDI RA,0xf000
    AND RA,VAL
    SRI RA,12
    PUSH VAL,RS
    PUSH IDX,RS
    JRIL _SYSCALL_DOT_HEXDIGIT
    POP IDX,RS
    POP VAL,RS
    SLI  VAL,4
    SUBI IDX,1
    JRI[NZ] _SYSCALL_DOT_HEX_LOOP
    JRI _SYSCALL_DOT_RETURN

_SYSCALL_DOT_RETURN:
    ; Restore registers
    POP R5,RS
    POP R4,RS
    POP R3,RS
    POP R2,RS
    POP R1,RS
    POP R0,RS
    POP RL,RS
    JP RL

_SYSCALL_DOT_HEXDIGIT:
    ; ( RA=digit )
    PUSH RL,RS
    CMPAI 0x0a
    JRI[NC] _SYSCALL_DOT_HEXDIGIT_GT9
    ; 0-9
    ADDAI '0'
    JRI _SYSCALL_DOT_HEXDIGIT_OUT
_SYSCALL_DOT_HEXDIGIT_GT9:
    SUBAI 0x0a
    ADDAI 'a'
_SYSCALL_DOT_HEXDIGIT_OUT:
    JRIL SYSCALL_UART_TX_BYTE
    JRI _SYSCALL_DOT_RETURN

UD_DIV: 
    ; Internal routine passes args and results in registers
    ; Unsigned double division
    ;   - {R1,R0} are 24-bit dividend
    ;   - R2 is 8-bit quotient
    ; Returns
    ;   - R0 contains 16-bit quotient
    ;   - R1 contains 8-bit remainder
    ; Destroys
    ;   - RA
    ;
    ;
    MOVAI 0x10 ; 16-bits to work on
_UD_DIV_LOOP:
    ADD R1,R1
    ADD R0,R0
    JRI[NC] _UD_DIV_LOOP_1
    ; Increment the MSB
    ADDI R1,1
_UD_DIV_LOOP_1:
    SUB R1,R2
    JRI[M] _UD_DIV_SKIP ; 
    ADDI R0,1 ; Set low bit
    JRI _UD_DIV_CONT
_UD_DIV_SKIP:
    ADD R1,R2
_UD_DIV_CONT:
    SUBI RA,1
    JRI[NZ] _UD_DIV_LOOP
_UD_DIV_DONE:
    JP RL

C_TO_I:
    ; Attempt to convert the hex char in RA to a valid number
    ; Return the number in RA, or -1 if no converted
    ; Only affects RA
    CMPAI '0'
    JRI[C] C_TO_I_INVALID
    SUBAI '0'
    CMPAI 10
    JRI[NC] C_TO_I_GT_9
    JP RL ; return the value
C_TO_I_GT_9:
    SUBAI 7 ; Put A at 10
    CMPAI 10
    JRI[C] C_TO_I_INVALID ; less than 'A'
    CMPAI 16
    JRI[NC] C_TO_I_LOWER_CASE ; greater than 'F'
    JP RL ; return value
C_TO_I_LOWER_CASE:
    SUBAI 32
    CMPAI 10
    JRI[C] C_TO_I_INVALID
    CMPAI 16
    JRI[NC] C_TO_I_INVALID
    JP RL
C_TO_I_INVALID:
    MOVAS -1
    JP RL


SYSCALL_NUMBER:
  ; Convert the token at the current DP to a number
  ; Ignores the system BASE. Expects the number base to be specified
  ; <no prefix> - decimal
  ; 0x          - hex
  ; 0b          - binary
  ; a character literal may be represented
  ;   'c'      - the trailing ' is not optional as in GForth
  ;   '\n'     - backslashes are allowed for \n, \t, \r and \0
  ;
  ; ( dp -- number true ) | ( dp -- false )
  .ALIAS R0,DP
  .ALIAS R1,NUM
  .ALIAS R2,BASE
  .ALIAS RA,CHAR
  .ALIAS R4,LEN
  .ALIAS R5,SIGN
  .ALIAS R6,TMP

  PUSH RL,RS
  PUSH R0,RS
  PUSH R1,RS
  PUSH R2,RS
  PUSH RA,RS
  PUSH R4,RS
  PUSH R5,RS
  PUSH R6,RS
    
  POP DP,SP
  LD LEN,DP
  ; Actually got something to parse?
  CMPI LEN,0
  JRI[Z] SYSCALL_NUMBER_FAILED
  ; Yes we do
  ADDI DP,2
  MOVI NUM,0
  MOVI SIGN,0 ; Positive
  ; Length of 1 means it must be parsed as decimal
  LD_B CHAR,DP
  CMPI LEN,1
  JRI[Z] SYSCALL_NUMBER_DECIMAL
  ; Longer than 1
  ; Is the first char a minus sign?
  ; Is so, must be decimal
  CMPAI '-'
  JRI[NZ] SYSCALL_NUMBER_NOT_NEGATIVE
  MOVI SIGN,1
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  JRI SYSCALL_NUMBER_DECIMAL
SYSCALL_NUMBER_NOT_NEGATIVE:
  CMPAI '\''
  JRI[NZ] SYSCALL_NUMBER_NOT_LITERAL
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  JRI SYSCALL_NUMBER_LITERAL
SYSCALL_NUMBER_NOT_LITERAL:
  ; First char a '0' in which case check for a base
  CMPAI '0'
  JRI[NZ] SYSCALL_NUMBER_DECIMAL
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  ; check for valid bases (x or b)
  LDI TMP,'x'
  CMP CHAR,TMP
  JRI[NZ] SYSCALL_NUMBER_NOT_HEX
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  JRI SYSCALL_NUMBER_HEX
SYSCALL_NUMBER_NOT_HEX:
  LDI TMP,'b'
  CMP CHAR,TMP
  JRI[NZ] SYSCALL_NUMBER_DECIMAL
  ADDI DP,1
  SUBI LEN,1
  LD_B CHAR,DP
  JRI SYSCALL_NUMBER_BIN
SYSCALL_NUMBER_DECIMAL:
  ; We got here! It should be a decimal number
  MOVI BASE,10
  JRI SYSCALL_NUMBER_CONVERT
SYSCALL_NUMBER_BIN:
  MOVI BASE,2
  JRI SYSCALL_NUMBER_CONVERT
SYSCALL_NUMBER_HEX:
  LDI BASE,16

SYSCALL_NUMBER_CONVERT:
  ; Current char to convert in CHAR, remaining length in LEN
  MUL NUM,BASE
  LD_B CHAR,DP
  JRIL C_TO_I
  ; If the return value is negative, then the conversion failed
  BITI RA,15
  JRI[NZ] SYSCALL_NUMBER_FAILED
  MOV RB,RA
  CMP BASE,RB
  JRI[C] SYSCALL_NUMBER_FAILED ; > BASE
  JRI[Z] SYSCALL_NUMBER_FAILED ; or == BASE
  ADD NUM,CHAR
  ADDI DP,1
  SUBI LEN,1
  JRI[NZ] SYSCALL_NUMBER_CONVERT
  ; We're done
SYSCALL_NUMBER_DONE:
  CMPI SIGN,1
  JRI[NZ] SYSCALL_NUMBER_RESULT
  MOVI TMP,0
  SUB TMP,NUM
  MOV NUM,TMP
SYSCALL_NUMBER_RESULT:  
  PUSH NUM,SP
  MOVI R0,1
  PUSH R0,SP
  JRI SYSCALL_NUMBER_RETURN

SYSCALL_NUMBER_LITERAL:
  ; Allow for the following backslashed characters
  ; \0
  ; \n
  ; \t
  ; \r
  ; \\
  ; All other chars are converted directly
  LD_B CHAR,DP
  CMPAI '\\'
  JRI[NZ] SYSCALL_NUMBER_NOT_BACKSLASH
  ADDI DP,1
  SUBI LEN,1
  JRI[Z] SYSCALL_NUMBER_FAILED ; nothing left to convert
  ; Ok what was backslashed?
  CMPAI '\\'
  JRI[NZ] SYSCALL_NUMBER_NOT_BACKSLASH
  LDI NUM,'\\'
  JRI SYSCALL_NUMBER_LITERAL_LAST
  CMPAI '0'
  JRI[NZ] SYSCALL_NUMBER_NOT_ZERO
  MOVI NUM,0
  JRI SYSCALL_NUMBER_LITERAL_LAST
SYSCALL_NUMBER_NOT_ZERO:  
  CMPAI 'n'
  JRI[NZ] SYSCALL_NUMBER_NOT_N
  LDI NUM,'\n'
  JRI SYSCALL_NUMBER_LITERAL_LAST
SYSCALL_NUMBER_NOT_N:
  CMPAI 't'
  JRI[NZ] SYSCALL_NUMBER_NOT_T
  LDI NUM,'\t'
  JRI SYSCALL_NUMBER_LITERAL_LAST
SYSCALL_NUMBER_NOT_T:
  CMPAI 'r'
  JRI[NZ] SYSCALL_NUMBER_NOT_BACKSLASH
  LDI NUM,'\r'
  JRI SYSCALL_NUMBER_LITERAL_LAST

SYSCALL_NUMBER_NOT_BACKSLASH:
  ; Just grab the char at the DP
  LD NUM,DP

SYSCALL_NUMBER_LITERAL_LAST:
  ; Does it end with a single quote?
  ; if not we have a problem
  ADDI DP,1
  SUBI LEN,1
  LD_B RA,DP
  CMPAI '\''
  JRI[NZ] SYSCALL_NUMBER_FAILED
  SUBI LEN,1
  ; There should be nothing left
  JRI[NZ] SYSCALL_NUMBER_FAILED
  ; We're good
  JRI SYSCALL_NUMBER_DONE

SYSCALL_NUMBER_FAILED:
  MOVI R0,0
  PUSH R0,SP

SYSCALL_NUMBER_RETURN:
  POP R6,RS
  POP R5,RS
  POP R4,RS
  POP RA,RS
  POP R2,RS
  POP R1,RS
  POP R6,RS
  POP RL,RS
  JP RL



CORE_PATCH_VOCABULARY:
  .DATA CORE_VOCABULARY ; Points to the end of the vocabulary on a cold start
                        ; Updated by EXPAND to include all defined words
CORE_PATCH_DP:
  .DATA #RAMSTART       ; Initialise the DP from here. Updated by EXPAND
CORE_PATCH_CURRENT:
  .DATA %CURRENT        ; save this address here so the write_cpp syscall can find it
CORE_PATCH_FENCE:
  .DATA FENCE           ; 

COLD:
  LDI RA,CORE_PATCH_DP
  LD RA,RA                ; Address of the cold-boot end of the dictionary
  LDI RB,%DICTIONARY_POINTER
  ST RA,RB

  LDI RA,CORE_PATCH_VOCABULARY
  LD RA,RA
  LDI RB,%CORE
  ST RA,RB

  LDI RA,%CURRENT
  ST RB,RA
  LDI RA,%CONTEXT
  ST RB,RA

  LDI RA,CORE_PATCH_FENCE ; At cold-start, FENCE is FENCE (!)
  LD RA,RA
  LDI RB,%FENCE
  ST RA,RB

  LDI RA,%USER_TOP
  LDI RB,USER_VARS
  ST RB,RA

  LDI RA,%TOKEN_HANDLER
  MOVI RB,0
  ST RB,RA

STAR_RESTART: ; Restart from here if a runtime error occurs
  LDI SP,#SPTOP
  LDI RS,#RSTOP

  ; Set LBUF_END to LBUF_DATA
  LDI RA,%LBUF_DATA
  LDI RB,%LBUF_END
  ST RA,RB

  ; Start with BASE set to HEX
  LDI RA,#BASE_HEX
  LDI RB,%BASE
  ST RA,RB

  ; Execute mode
  LDI RA,#MODE_EXECUTE
  LDI RB,%MODE
  ST RA,RB

  LDI RA,#STATE_NOT_FOUND
  LDI RB,%STATE
  ST RA,RB

  LDI RA,0x0a
  LDI RB,%BASE
  ST RA,RB

  LDI RI,OUTER_CA
  JPI NEXT

; Beginning of the inner interpreter
STAR_COLON:
  .N "*:"
  .DATA 0
STAR_COLON_WA: .DATA STAR_COLON_CA
STAR_COLON_CA:
COLON: 
  PUSH FP,RS
  PUSH RI,RS
  MOV FP,RS ; Frame pointer
  MOV RI,WA
  JRI NEXT
STAR_SEMI:
  .N "*;"
  .DATA STAR_COLON
STAR_SEMI_WA: .DATA STAR_SEMI_CA ; I.e. the address of the next word
STAR_SEMI_CA:
  MOV RS,FP
  POP RI,RS
  POP FP,RS
NEXT:
  LD WA,RI ; WA <- (I)
  ADDI RI,2
RUN:
  LD RA,WA
  ADDI WA,2
  JP RA

MESSAGES: ; SYSTEM MESSAGES LIVE HERE
MSG_HELLO:               .DATA 23 .SDATA "Hello! I'm a TIL :-) >>"
MSG_UNKNOWN_TOKEN:       .DATA 14 .SDATA "Unknown token "
MSG_IMMEDIATE_ONLY:      .DATA 36 .SDATA "Immediate words forbidden at runtime"
MSG_COMPILE_ONLY:        .DATA 39 .SDATA "Compile-time words forbidden at runtime"
MSG_RUNTIME_ONLY:        .DATA 39 .SDATA "Runtime words forbidden at compile-time"
MSG_SYSTEM_ERROR:        .DATA 12 .SDATA "System error"
MSG_WORD_NOT_FOUND:      .DATA 14 .SDATA "Word not found"
MSG_PROMPT:              .DATA  5 .SDATA "OK >>"
MSG_SP_UNDERFLOW:        .DATA 15 .SDATA "Stack underflow"
MSG_RS_UNDERFLOW:        .DATA 22 .SDATA "Return stack underflow"
MSG_UNHANDLED_INTERRUPT: .DATA 27 .SDATA "******** INTERRUPT ********"

BIT_PASSIVE:
  .N "#PASSIVE"
  .DATA STAR_SEMI
BIT_PASSIVE_WA: .DATA BIT_PASSIVE_CA
BIT_PASSIVE_CA:
  LDI RA,#HEADER_PASSIVE
  PUSH RA,SP
  JPI NEXT

BIT_IMMEDIATE:
  .N "#IMMEDIATE"
  .DATA BIT_PASSIVE
BIT_IMMEDIATE_WA: .DATA BIT_IMMEDIATE_CA
BIT_IMMEDIATE_CA:
  LDI RA,#HEADER_IMMEDIATE
  PUSH RA,SP
  JPI NEXT

BIT_RUNTIME:
  .N "#RUNTIME"
  .DATA BIT_IMMEDIATE
BIT_RUNTIME_WA: .DATA BIT_RUNTIME_CA
BIT_RUNTIME_CA:
  LDI RA,#HEADER_RUNTIME
  PUSH RA,SP
  JPI NEXT

BIT_EXECUTIVE:
  .N "#EXECUTIVE"
  .DATA BIT_RUNTIME
BIT_EXECUTIVE_WA: .DATA BIT_EXECUTIVE_CA
BIT_EXECUTIVE_CA:
  LDI RA,#HEADER_EXECUTIVE
  PUSH RA,SP
  JPI NEXT

BIT_COMPILETIME:
  .N "#COMPILETIME"
  .DATA BIT_EXECUTIVE
BIT_COMPILETIME_WA: .DATA BIT_COMPILETIME_CA
BIT_COMPILETIME_CA:
  LDI RA,#HEADER_COMPILETIME
  PUSH RA,SP
  JPI NEXT

BIT_HAS_LOCALS:
  .N "#HAS_LOCALS"
  .DATA BIT_COMPILETIME
BIT_HAS_LOCALS_WA: .DATA BIT_HAS_LOCALS_CA
BIT_HAS_LOCALS_CA:
  LDI RA,#HEADER_HAS_LOCALS
  PUSH RA,SP
  JPI NEXT

WORDLEN:
; ( wa -- len )
  .N "WORDLEN"
  .DATA BIT_HAS_LOCALS
WORDLEN_WA: .DATA WORDLEN_CA
WORDLEN_CA:
  LDI RA,#HEADER_MASK
  POP RB,SP
  LD RB,RB
  AND RB,RA
  PUSH RB,SP
  JPI NEXT

SCODE:
  .N "SCODE"
  .DATA WORDLEN
SCODE_WA:
  .DATA COLON
SCODE_CA:
  ; Change the CA of the word being defined
  ; to point to the machine code following
  ; SCODE in the defining word
  ; clean up the stack so we pop up a level
  .DATA POP_RS_WA
  .DATA CASTORE_WA
  .DATA STAR_SEMI_WA

SEMI_CODE:
  .I ";CODE"
  .DATA SCODE
SEMI_CODE_WA: .DATA COLON
SEMI_CODE_CA:
  .DATA STAR_HASH_WA
  .DATA SCODE_WA
  .DATA COMMA_WA
  .DATA ZERO_WA
  .DATA MODE_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA

ALLOT:
  .N "ALLOT"
  .DATA SEMI_CODE
ALLOT_WA: .DATA COLON
ALLOT_CA:
  .DATA ZERO_WA
  .DATA STAR_DO_WA
ALLOT_LOOP:
  .DATA ZERO_WA
  .DATA COMMA_WA
  .DATA STAR_LOOP_WA
  .DATA ALLOT_LOOP
  .DATA STAR_SEMI_WA

VALLOT:
; Allot space on the variables heap
; ( size-in-words -- start addr )
  .N "VALLOT"
  .DATA ALLOT
VALLOT_WA: .DATA COLON
  .DATA TWO_TIMES_WA
  .DATA VAR_USER_TOP_WA .DATA PLUS_STORE_WA
  .DATA STAR_SEMI_WA

VEXTEND:
; ( Extend a variable to the size on the stack in words )
  .N "VEXTEND"
  .DATA VALLOT
VEXTEND_WA: .DATA COLON
VEXTEND_CA:
  .DATA ONE_WA .DATA MINUS_WA
  .DATA VALLOT_WA
  .DATA STAR_SEMI_WA

BUILDS:
  .N "<BUILDS"
  .DATA VEXTEND
BUILDS_WA: .DATA COLON
BUILDS_CA:
  .DATA STAR_HASH_WA
  .DATA 0
  .DATA CONSTANT_WA ; Reserve a slot for DOES> to compile into
  .DATA STAR_SEMI_WA

VBUILDS:
; Builds a word and creates a variable
; of the same name
; Usage: 
;
; : VOCABULARY 
;    <VBUILDS ENTRY ! 
;    DOES> @ CONTEXT !
; ;
;
  .N "<VBUILDS"
  .DATA BUILDS
VBUILDS_WA: .DATA COLON
VBUILDS_CA:
  .DATA STAR_HASH_WA
  .DATA 0
  .DATA CONSTANT_WA ; Reserve a slot for DOES> to compile the jump address into
  ; Now create an anonymous variable and compile its address
  .DATA VAR_USER_TOP_WA
  .DATA AT_WA
  .DATA COMMA_WA    ; Store the initial value
  .DATA VAR_USER_TOP_WA
  .DATA AT_WA       ; Address to the stack
  .DATA VAR_USER_TOP_WA
  .DATA DUP_WA
  .DATA AT_WA
  .DATA TWO_PLUS_WA
  .DATA SWAP_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA

DOES:
  .N "DOES>"
  .DATA VBUILDS
DOES_WA: .DATA COLON
DOES_CA:
  .DATA POP_RS_WA
  .DATA ENTRY_WA
  .DATA WA_TO_CB_WA
  .DATA STORE_WA
  .DATA SCODE_WA

  PUSH FP,RS
  PUSH RI,RS
  MOV FP,RS ; Frame pointer
  LD RI,WA
  ADDI WA,2
  PUSH WA,SP
  JPI NEXT

CONSTANT:
  .N "CONSTANT"
  .DATA DOES
CONSTANT_WA:
  .DATA COLON
CONSTANT_CA:
  .DATA CREATE_WA
  .DATA COMMA_WA
  .DATA SCODE_WA
  LD RA,WA
  PUSH RA,SP 
  JPI NEXT

VARIABLE:
  ; Create a variable in the variables space
  ; ( initial-value -- )
  .N "VARIABLE"
  .DATA CONSTANT
VARIABLE_WA: .DATA COLON
VARIABLE_CA:
  .DATA VBUILDS_WA
  .DATA STORE_WA
  .DATA DOES_WA
  .DATA AT_WA
  .DATA STAR_SEMI_WA

CONST_NEXT:
  .N "#NEXT"
  .DATA VARIABLE
CONST_NEXT_WA: .DATA CONST_NEXT_CA
CONST_NEXT_CA:
  LDI RA,NEXT
  PUSH RA,SP
  JPI NEXT

SPTOP:
  .N "#SPTOP"
  .DATA CONST_NEXT
SPTOP_WA: .DATA SPTOP_CA
SPTOP_CA:
  LDI RA,#SPTOP
  PUSH RA,SP
  JPI NEXT

RSTOP:
  .N "#RSTOP"
  .DATA SPTOP
RSTOP_WA: .DATA RSTOP_CA
RSTOP_CA:
  LDI RA,#RSTOP
  PUSH RA,SP
  JPI NEXT

VAR_USER_TOP:
  .N "$USER-TOP"
  .DATA RSTOP
VAR_USER_TOP_WA: .DATA VAR_USER_TOP_CA
VAR_USER_TOP_CA:
  LDI RA,%USER_TOP
  PUSH RA,SP
  JPI NEXT

VAR_LBUF_IDX:
  .N "$LBUF-IDX"
  .DATA VAR_USER_TOP
VAR_LBUF_IDX_WA: .DATA VAR_LBUF_IDX_CA
VAR_LBUF_IDX_CA:
  LDI RA,%LBUF_IDX
  PUSH RA,SP
  JPI NEXT

VAR_TOKEN_HANDLER:
  .N "$TOKEN-HANDLER"
  .DATA VAR_LBUF_IDX
VAR_TOKEN_HANDLER_WA: .DATA VAR_TOKEN_HANDLER_CA
VAR_TOKEN_HANDLER_CA:
  LDI RA,%TOKEN_HANDLER
  PUSH RA,SP
  JPI NEXT

Q_TOKEN_HANDLER:
  .N "?TOKEN-HANDLER"
  .DATA VAR_TOKEN_HANDLER
Q_TOKEN_HANDLER_WA: .DATA COLON
Q_TOKEN_HANDLER_CA:
  .DATA STAR_HASH_WA .DATA %TOKEN_HANDLER
  .DATA AT_WA
  .DATA STAR_IF_WA ; Is something set?
  .DATA Q_TOKEN_HANDLER_NONE
  ; Yes, execute it
  .DATA STAR_TOKEN_HANDLER_WA
  .DATA STAR_ELSE_WA
  .DATA Q_TOKEN_HANDLER_DONE
Q_TOKEN_HANDLER_NONE:
  .DATA ZERO_WA
Q_TOKEN_HANDLER_DONE:
  .DATA STAR_SEMI_WA

STAR_TOKEN_HANDLER:
  .N "*TOKEN-HANDLER"
  .DATA Q_TOKEN_HANDLER
STAR_TOKEN_HANDLER_WA: .DATA STAR_TOKEN_HANDLER_CA
STAR_TOKEN_HANDLER_CA:
  LDI RA,%TOKEN_HANDLER
  LD RA,RA
  CMPI RA,0
  JRI[Z] STAR_TOKEN_HANDLER_NONE
  MOV WA,RA
  JPI RUN
STAR_TOKEN_HANDLER_NONE:
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT

IMMEDIATE:
  .N "IMMEDIATE"
  .DATA STAR_TOKEN_HANDLER
IMMEDIATE_WA: .DATA IMMEDIATE_CA
IMMEDIATE_CA:
  LDI RA,%CURRENT
  LD RB,RA ; point to vocab
  LD RB,RB ; point to word
  LD RA,RB ; get the word length
  LDI R0,#HEADER_IMMEDIATE
  OR RA,R0 ; Set the immediate bit
  ST RA,RB
  JPI NEXT

RUNTIME:
  .N "RUNTIME"
  .DATA IMMEDIATE
RUNTIME_WA: .DATA RUNTIME_CA
RUNTIME_CA:
  LDI RA,%CURRENT
  LD RB,RA ; point to vocab
  LD RB,RB ; point to word
  LD RA,RB ; get the word length
  LDI R0,#HEADER_RUNTIME
  OR RA,R0 ; Set the runtime bit
  ST RA,RB
  JPI NEXT


EXECUTIVE:
  .N "EXECUTIVE"
  .DATA RUNTIME
EXECUTIVE_WA: .DATA EXECUTIVE_CA
EXECUTIVE_CA:
  LDI RA,%CURRENT
  LD RB,RA ; point to vocab
  LD RB,RB ; point to word
  LD RA,RB ; get the word length
  LDI R0,#HEADER_EXECUTIVE
  OR RA,R0 ; Set the immediate and runtime bits
  ST RA,RB
  JPI NEXT

VOCABULARY:
  .N "VOCABULARY"
  .DATA EXECUTIVE
VOCABULARY_WA: .DATA COLON
VOCABULARY_CA:
  .DATA VBUILDS_WA
  .DATA ENTRY_WA
  .DATA SWAP_WA
  .DATA STORE_WA

  .DATA DOES_WA
  .DATA AT_WA
  .DATA CONTEXT_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA

CORE:   ; My definition. Should really be as defined using VOCABULARY
        ; But I don't understand how that works yet
        ; And it needs to store values in ram, not the code-body of the word
  .N "CORE"
  .DATA VOCABULARY
CORE_WA: .DATA CORE_CA
CORE_CA:
  LDI RA,%CORE
  LDI RB,%CONTEXT
  ST RA,RB
  JPI NEXT

STAR_LIT:
  .N "*\""
  .DATA CORE
STAR_LIT_WA: .DATA STAR_LIT_CA
STAR_LIT_CA:
  LD RA,RI ; Length to A
  PUSH RI,SP
  JRIL SYSCALL_TYPE
  ADD RI,RA
  ADDI RI,3
  CLRI RI,0 ; Word align
  JPI NEXT

RESTART:
  .N "RESTART"
  .DATA STAR_LIT
RESTART_WA: .DATA STAR_RESTART

; Test the stacks for underflow
; If there is underflow then print a message and restart
STAR_STACK:
  .N "*STACK"
  .DATA RESTART
STAR_STACK_WA: .DATA STAR_STACK_CA
STAR_STACK_CA:
  LDI R0,#SPTOP
  SUB R0,SP
  JRI[NC] STAR_STACK_CHECK_RS
  LDI SP,#SPTOP
  LDI RA,MSG_SP_UNDERFLOW
  PUSH RA,SP
  JRIL SYSCALL_TYPELN
STAR_STACK_CHECK_RS:
  LDI R0,#RSTOP
  SUB R0,RS
  JRI[NC] STAR_STACK_OK
  LDI RA,MSG_RS_UNDERFLOW    
  PUSH RA,SP
  JRIL SYSCALL_TYPELN
  JPI STAR_RESTART
STAR_STACK_OK:
  JPI NEXT

TYPE:
  .N "TYPE"  
  .DATA STAR_STACK   
TYPE_WA:
  .DATA TYPE_CA    ; This is the word address of TYPE
TYPE_CA:             ; The Code address
  JRIL SYSCALL_TYPE
  JPI NEXT

TYPELN:
  .N "TYPELN"     ; And the string's characters
  .DATA TYPE   
TYPELN_WA:
  .DATA TYPELN_CA    ; This is the word address of TYPE
TYPELN_CA:             ; The Code address
  JRIL SYSCALL_TYPELN
  JPI NEXT

EMIT:
  .N "EMIT"
  .DATA TYPELN
EMIT_WA: .DATA EMIT_CA
EMIT_CA:
  POP RA,SP
  JRIL SYSCALL_UART_TX_BYTE
  JPI NEXT

MESSAGE: ; Print a system message ( n -- )
  .N "MESSAGE"
  .DATA EMIT
MESSAGE_WA: .DATA MESSAGE_CA
MESSAGE_CA:
  POP RA,SP                ; Message number n in A (0-based)
  LDI RB,MESSAGES       ; B holds the message address
MESSAGE_LOOP:
  AND RA,RA               ; Is this the message we're looking for?
  JRI[Z] MESSAGE_FOUND
  LD R0,RB               ; Get the length of the message
  ADD RB,R0              ; Add to the address
  ADDI RB,3
  CLRI RB,0               ; Word-align
  SUBI RA,1             ; Decrement A
  JRI MESSAGE_LOOP
MESSAGE_FOUND:
  PUSH RB,SP              ; Message address to the stack
  JRIL SYSCALL_TYPE
  JPI NEXT

Q_PRINTABLE:
; ( char -- flag )
  .N "?PRINTABLE"
  .DATA MESSAGE
Q_PRINTABLE_WA: .DATA COLON
Q_PRINTABLE_CA:
  .DATA STAR_HASH_WA .DATA 0x7e
  .DATA STAR_HASH_WA .DATA 0x20
  .DATA BETWEEN_WA
  .DATA STAR_SEMI_WA

DOT:  ; The Forth word "." to print the value on the top of the stack
  .N "."
  .DATA Q_PRINTABLE
DOT_WA:
  .DATA DOT_CA
DOT_CA:
  LDI RA,%BASE
  LD RB,RA     ; Current base in B
  PUSH RB,SP      ; Push it to the stack
  MOVI RA,1
  PUSH RA,SP
  JRIL SYSCALL_DOT
  JPI NEXT

DOT_U:  ; The Forth word "." to print the unsigned value on the top of the stack
  .N ".U"
  .DATA Q_PRINTABLE
DOT_U_WA:
  .DATA DOT_U_CA
DOT_U_CA:
  LDI RA,%BASE
  LD RB,RA     ; Current base in B
  PUSH RB,SP   ; Push it to the stack
  MOVI RA,0
  PUSH RA,SP
  JRIL SYSCALL_DOT
  JPI NEXT

DOT_C:  ; The Forth word ".C" to print the value on the top of the stack
  .N ".C"
  .DATA DOT
DOT_C_WA:
  .DATA DOT_C_CA
DOT_C_CA:
  POP RA,SP
  ANDAI 0xff
  PUSH RA,SP
  LDI RA,%BASE
  LD RB,RA     ; Current base in B
  PUSH RB,SP   ; Push it to the stack
  MOVI RA,0
  PUSH RA,SP   ; unsigned
  JRIL SYSCALL_DOT
  JPI NEXT

DOT_Q_C:
; Print the char if it is ?PRINTABLE
; Otherwise print a space
  .N ".?C"
  .DATA DOT_C
DOT_Q_C_WA: .DATA COLON
DOT_Q_C_CA:
  .DATA DUP_WA
  .DATA Q_PRINTABLE_WA
  .DATA STAR_IF_WA
  .DATA DOT_Q_C_SPACE
  .DATA EMIT_WA
  .DATA STAR_ELSE_WA
  .DATA DOT_Q_C_DONE
DOT_Q_C_SPACE:
  .DATA DOT_ASPACE_WA
  .DATA DROP_WA
DOT_Q_C_DONE:
  .DATA STAR_SEMI_WA

MODE:
  .N "MODE"
  .DATA DOT_Q_C
MODE_WA:
  .DATA MODE_CA
MODE_CA:
  LDI RA,%MODE
  PUSH RA,SP
  JPI NEXT

BASE:
  .N "BASE"
  .DATA MODE
BASE_WA: .DATA BASE_CA
BASE_CA:
  LDI RA,%BASE
  PUSH RA,SP
  JPI NEXT

HEX:
  .N "HEX"
  .DATA BASE
HEX_WA: .DATA HEX_CA
HEX_CA:
  LDI RB,0x10
  LDI RA,%BASE
  ST RB,RA
  JPI NEXT

DECIMAL:
  .N "DECIMAL"
  .DATA HEX
DECIMAL_WA: .DATA DECIMAL_CA
DECIMAL_CA:
  LDI RA,%BASE
  MOVI RB,10
  ST RB,RA
  JPI NEXT

BINARY:
  .N "BINARY"
  .DATA DECIMAL
BINARY_WA: .DATA BINARY_CA
BINARY_CA:
  LDI RA,%BASE
  MOVI RB,2
  ST RB,RA
  JPI NEXT

AT:
  .N "@"
  .DATA BINARY
AT_WA:
  .DATA AT_CA
AT_CA:
  POP RA,SP
  LD RA,RA
  PUSH RA,SP
  JPI NEXT

C_AT:
  .N "C@"
  .DATA AT
C_AT_WA:
  .DATA C_AT_CA
C_AT_CA:
  POP RA,SP
  LD RB,RA
  LDI RA,0xff
  AND RB,RA
  PUSH RB,SP
  JPI NEXT

STORE:
  .N "!"
  .DATA C_AT
STORE_WA:
  .DATA STORE_CA
STORE_CA:
  POP RA,SP
  POP RB,SP
  ST RB,RA
  JPI NEXT

PLUS:
  .N "+"
  .DATA STORE
PLUS_WA: 
  .DATA PLUS_CA
PLUS_CA:
  POP RA,SP
  POP RB,SP
  ADD RA,RB
  PUSH RA,SP
  JPI NEXT

D_AT:
  .N "D@"
  .DATA PLUS
D_AT_WA: .DATA D_AT_CA
D_AT_CA:
  ; ( address -- double-data )
  POP R0,SP ; Address
  LD R1,R0 ; Low word
  ADDI R0,2
  LD R2,R0
  PUSH R1,SP
  PUSH R2,SP
  JPI NEXT

D_STORE:
  .N "D!"
  .DATA D_AT
D_STORE_WA: .DATA D_STORE_CA
D_STORE_CA:
; ( double-data address -- )
  POP R0,SP ; address
  POP R1,SP ; DH
  POP R2,SP ; DL 
  ST R0,R2
  ADDI R0,2
  ST R0,R1
  JPI NEXT

;
; Common aliases for double alu ops
.ALIAS R0,AH
.ALIAS R1,AL
.ALIAS R2,BH
.ALIAS R3,BL

D_ADD:
  .N "D+"
  .DATA D_STORE
D_ADD_WA: .DATA D_ADD_CA
D_ADD_CA:
  POP AH,SP
  POP AL,SP
  POP BH,SP
  POP BL,SP
  ADD AL,BL
  JRI[NC] D_ADD_NC
  ADDI AH,1
D_ADD_NC:
  ADD AH,BH
  PUSH AL,SP
  PUSH AH,SP
  JPI NEXT

D_AND:
  .N "DAND"
  .DATA D_ADD
D_AND_WA: .DATA D_AND_CA
D_AND_CA:
  POP AH,SP
  POP AL,SP
  POP BH,SP
  POP BL,SP
  AND AH,BH
  AND AL,BL
  PUSH AL,SP
  PUSH AH,SP   
  JPI NEXT

D_OR:
  .N "DOR"
  .DATA D_AND
D_OR_WA: .DATA D_OR_CA
D_OR_CA:
  POP AH,SP
  POP AL,SP
  POP BH,SP
  POP BL,SP
  OR AH,BH
  OR AL,BL
  PUSH AL,SP
  PUSH AH,SP  
  JPI NEXT

D_INVERT:
  .N "DINVERT"
  .DATA D_OR
D_INVERT_WA: .DATA D_INVERT_CA
D_INVERT_CA:
  POP AH,SP
  POP AL,SP
  MOVAS -1
  XOR AH,RA
  XOR AL,RA
  PUSH AL,SP
  PUSH AH,SP  
  JPI NEXT

D_SUB:
  .N "D-"
  .DATA D_INVERT
D_SUB_WA: .DATA D_SUB_CA
D_SUB_CA:
  POP AH,SP
  POP AL,SP
  POP BH,SP
  POP BL,SP
  SUB BL,AL
  JRI[NC] D_SUB_NC
  SUBI BH,1
D_SUB_NC:
  SUB BH,AH
  PUSH BL,SP
  PUSH BH,SP  
  JRI NEXT

D_MUL:
  .N "D*"
  .DATA D_SUB
D_MUL_WA: .DATA D_MUL_CA
D_MUL_CA:
  .ALIAS R4,RH
  .ALIAS R5,RL
  POP AH,SP
  POP AL,SP
  POP BH,SP
  POP BL,SP
  ; RL = AL * BL
  ; RH = AL * BH + AH * BL
  ; We ignore any overflow
  MOV RL,AL
  MUL RL,BL
  MUL AL,BH
  MUL AH,BL
  ADD AH,AL
  PUSH RL,SP
  PUSH AH,SP
  JRI NEXT

D_DIV:
  .N "D/"
  .DATA D_MUL
D_DIV_WA: .DATA D_DIV_CA
D_DIV_CA:
  ; Uses the slow division algorithm
  ; N = Numerator (n bits)
  ; D = Denominator
  ; Q = 0  Quotient
  ; R = 0  Remainder
  ; if D == 0 then Div0 Exception
  ; for i = n-1 downto 0 do
  ;   R = R << 1
  ;   R(0) = N(i)
  ;   if R >= D then
  ;     R = R - D
  ;     Q(i) = 1
  ;   end
  ;  end
  .ALIAS R0,NUMH
  .ALIAS R1,NUML
  .ALIAS R2,DENH
  .ALIAS R3,DENL
  .ALIAS R4,QH
  .ALIAS R5,QL
  .ALIAS R6,REMH
  .ALIAS R7,REML
  .ALIAS RA,IDX
  POP DENH,SP
  POP DENL,SP
  POP NUMH,SP
  POP NUML,SP
  MOVI QH,0
  MOVI QL,0
  MOVI REMH,0
  MOVI REML,0
  MOVAI 31 ; IDX=31

D_DIV_LOOP:
  ; R = R <<1
  SLI REMH,1
  SLI REML,1
  JRI[NC] D_DIV_LOOP_NO_REM_C
  SETI REMH,0
D_DIV_LOOP_NO_REM_C:
  CMPAI 16 ; IDX < 15?
  JRI[NC] D_DIV_LOOP_HIGH_WORD
  ; We're dealing with a bit less than 16, so in the low word
  BIT NUML,IDX
  JRI[Z] D_DIV_LOOP_TEST_R_GTE_D
  SETI REML,0
D_DIV_LOOP_HIGH_WORD:
  MOV RB,IDX
  SUBI RB,15
  SUBI RB,1
  BIT NUMH,RB
  JRI[Z] D_DIV_LOOP_TEST_R_GTE_D
  SETI REML,0

D_DIV_LOOP_TEST_R_GTE_D:
  ; if R >= D
  CMP DENH,REMH
  JRI[C] D_DIV_LOOP_R_GTE_D
  JRI[NZ] D_DIV_LOOP_NEXT
  CMP DENL,REML
  JRI[C] D_DIV_LOOP_R_GTE_D
  JRI[NZ] D_DIV_LOOP_NEXT

D_DIV_LOOP_R_GTE_D:
  ; R = R - D
  SUB REML,DENL
  JRI[NC] D_DIV_LOOP_R_SUB_D_NC
  SUBI REMH,1
D_DIV_LOOP_R_SUB_D_NC:
  SUB REMH,DENH

  ; Q(i) = 1
  CMPAI 16 ; IDX < 15?
  JRI[NC] D_DIV_LOOP_Q_HIGH_WORD  
  SET QL,IDX
  JRI D_DIV_LOOP_NEXT
D_DIV_LOOP_Q_HIGH_WORD:
  MOV RB,IDX
  SUBI RB,15
  SUBI RB,1
  SET QH,RB

D_DIV_LOOP_NEXT:
  CMPI IDX,0
  JRI[NZ] D_DIV_LOOP_MORE
  JRI D_DIV_LOOP_DONE
D_DIV_LOOP_MORE:
  SUBI IDX,1
  JRI D_DIV_LOOP

D_DIV_LOOP_DONE:
  ; Push the quotient and abandon the remainder for now(!)
  PUSH QL,SP
  PUSH QH,SP

  JPI NEXT

D_SR:
  .N "D>>"
  .DATA D_DIV
D_SR_WA: .DATA D_SR_CA
D_SR_CA:
  .ALIAS R0,AH
  .ALIAS R1,AL
  .ALIAS RA,SHIFT
  .ALIAS R2,MASK
  .ALIAS R3,FF
  .ALIAS R4,BSHIFT

  POP SHIFT,SP
  POP AH,SP
  POP AL,SP
  ; Just use a dumb loop for now
D_SR_LOOP:
  CMPI SHIFT,0
  JRI[Z] D_SR_DONE
  SRI AL,1
  BITI AH,0
  JRI[Z] D_SR_HBIT_Z
  SETI AL,15
D_SR_HBIT_Z:
  SRI AH,1
  SUBI SHIFT,1
  JRI D_SR_LOOP
D_SR_DONE:
  PUSH AL,SP
  PUSH AH,SP
  JRI NEXT

D_SL:
  .N "D<<"
  .DATA D_SR
D_SL_WA: .DATA D_SL_CA
D_SL_CA:
  .ALIAS R0,AH
  .ALIAS R1,AL
  .ALIAS R2,SHIFT
  POP SHIFT,SP
  POP AH,SP
  POP AL,SP 
D_SL_LOOP:
  CMPI SHIFT,0
  JRI[Z] D_SL_DONE
  SLI AH,1
  SLI AL,1
  JRI[NC] D_SL_HBIT_Z
  SETI AH,0
D_SL_HBIT_Z:
  SUBI SHIFT,1
  JRI D_SL_LOOP
D_SL_DONE:  
  PUSH AL,SP
  PUSH AH,SP
  JRI NEXT

D_SWAP:
  .N "DSWAP"
  .DATA D_SL
D_SWAP_WA: .DATA D_SWAP_CA
D_SWAP_CA:
  POP R0,SP ; H1
  POP R1,SP ; L1
  POP R2,SP ; H2
  POP R3,SP ; L2
  PUSH R1,SP ; L1
  PUSH R0,SP ; L1 H1
  PUSH R3,SP ; L1 H1 L2
  PUSH R2,SP ; L1 H1 L2 H2
  JPI NEXT

D_DUP:
  .N "DDUP"
  .DATA D_SWAP
D_DUP_WA: .DATA D_DUP_CA
D_DUP_CA:
  POP R0,SP ; H1
  POP R1,SP ; L1
  PUSH R1,SP ; L1
  PUSH R0,SP ; L1 H1
  PUSH R1,SP ; L1
  PUSH R0,SP ; L1 H1
  JPI NEXT

PLUS_STORE:
  .N "+!"
  .DATA D_DUP
PLUS_STORE_WA: .DATA PLUS_STORE_CA
PLUS_STORE_CA:
  POP RA,SP
  POP RB,SP
  LD R0,RA
  ADD R0,RB
  ST R0,RA
  JPI NEXT

MINUS:
  .N "-"
  .DATA PLUS_STORE
MINUS_WA: 
  .DATA MINUS_CA
MINUS_CA:
  POP RA,SP
  POP RB,SP
  SUB RB,RA
  PUSH RB,SP
  JPI NEXT

TIMES:
  .N "*"
  .DATA MINUS
TIMES_WA: 
  .DATA TIMES_CA
TIMES_CA:
  POP RA,SP
  POP RB,SP
  MUL RB,RA
  PUSH RB,SP
  JPI NEXT

DIV:
  .N "/"
  .DATA TIMES
DIV_WA: 
  .DATA DIV_CA
DIV_CA:
  POP R2,SP
  POP R0,SP
  MOVI R1,0
  JRIL UD_DIV
  PUSH R0,SP
  JPI NEXT

AND:
  .N "AND"
  .DATA DIV
AND_WA: 
  .DATA AND_CA
AND_CA:
  POP RA,SP
  POP RB,SP
  AND RB,RA
  PUSH RB,SP
  JPI NEXT

OR:
  .N "OR"
  .DATA AND
OR_WA: .DATA OR_CA
OR_CA:
  POP RA,SP
  POP RB,SP
  OR RA,RB
  PUSH RA,SP
  JPI NEXT

NOT:
  .N "NOT"
  .DATA OR
NOT_WA: .DATA NOT_CA
NOT_CA:
  POP RA,SP
  CMPI RA,0
  JRI[Z] NOT_IS_ZERO
  MOVI RA,0 ; invert
  PUSH RA,SP
  JPI NEXT
NOT_IS_ZERO:
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT

INVERT:
  .N "INVERT"
  .DATA NOT
INVERT_WA: .DATA INVERT_CA
INVERT_CA:
  POP RA,SP
  XOR RA,RA
  PUSH RA,SP
  JPI NEXT

EQUALS:
  .N "="
  .DATA INVERT
EQUALS_WA: .DATA EQUALS_CA
EQUALS_CA:
  POP RA,SP
  POP RB,SP
  CMP RA,RB
  JRI[NZ] EQUALS_FALSE
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT
EQUALS_FALSE:
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT

NOT_EQUALS:
  .N "!="
  .DATA EQUALS
NOT_EQUALS_WA: .DATA NOT_EQUALS_CA
NOT_EQUALS_CA:
  POP RA,SP
  POP RB,SP
  CMP RA,RB
  JRI[NZ] NOT_EQUALS_TRUE
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT
NOT_EQUALS_TRUE:
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT

; The comparison operators all assume signed arguments
GT:
; ( a b -- a>b )
  .N ">"
  .DATA NOT_EQUALS
GT_WA: .DATA GT_CA
GT_CA:
  POP RB,SP
  POP RA,SP
GT_CMP:
  CMP RB,RA
  JRI[NP] GT_GLE
  JRI[Z] GT_GLE
  ; A is <= B
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT
GT_GLE:
  ; A is <= B
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT

GTE:
  .N ">="
  .DATA GT
GTE_WA: .DATA GTE_CA
GTE_CA:
  POP RB,SP
  POP RA,SP
GTE_CMP:
  CMP RA,RB
  JRI[P] GTE_LT
  ; A is < B
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT
GTE_LT:
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT

; Default less-than works for signed numbers
LT:
  .N "<"
  .DATA GTE
LT_WA: .DATA LT_CA
LT_CA:
  POP RB,SP
  POP RA,SP
  CMP RA,RB
  JRI[P] LT_LT
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT
LT_LT:
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT

LTE:
  .N "<="
  .DATA LT
LTE_WA: .DATA LTE_CA
LTE_CA:
  POP RB,SP
  POP RA,SP
  CMP RA,RB
  JRI[P] LTE_LTE
  JRI[Z] LTE_LTE
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT
LTE_LTE:
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT


; Unsigned comparisons
ULT:
  .N "U<"
  .DATA LTE
ULT_WA: .DATA ULT_CA
ULT_CA:
  POP RB,SP
  POP RA,SP
  CMP RA,RB
  JRI[C] ULT_TRUE
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT
ULT_TRUE:
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT  

; Unsigned comparisons
UGT:
  .N "U>"
  .DATA ULT
UGT_WA: .DATA UGT_CA
UGT_CA:
  POP RA,SP
  POP RB,SP
  CMP RA,RB
  JRI[C] UGT_TRUE
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT
UGT_TRUE:
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT  

BETWEEN:
; ( val ge le -- flag )
; Signed
  .N ">=<"
  .DATA UGT
BETWEEN_WA: .DATA BETWEEN_CA
BETWEEN_CA:
  .ALIAS R0,LE
  .ALIAS R1,GE
  .ALIAS R2,VAL
  POP LE,SP
  POP GE,SP
  POP VAL,SP
  CMP VAL,LE
  JRI[P] NOT_BETWEEN
  CMP GE,VAL
  JRI[P] NOT_BETWEEN
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT
NOT_BETWEEN:
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT

WITHIN:
; ( val gt lt -- flag )
  .N ">|<"
  .DATA BETWEEN
WITHIN_WA: .DATA WITHIN_CA
WITHIN_CA:
  .ALIAS R0,LE
  .ALIAS R1,GE
  .ALIAS R2,VAL
  POP LE,SP
  POP GE,SP
  POP VAL,SP
  CMP VAL,LE
  JRI[P] NOT_WITHIN
  JRI[Z] NOT_WITHIN
  CMP GE,VAL
  JRI[P] NOT_WITHIN
  JRI[Z] NOT_WITHIN
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT
NOT_WITHIN:
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT



ZERO_EQUALS:
  .N "0="
  .DATA WITHIN
ZERO_EQUALS_WA: .DATA ZERO_EQUALS_CA
ZERO_EQUALS_CA:
  POP RA,SP
  CMPI RA,0
  MOVI RB,1
  JRI[Z] ZERO_EQUALS_TRUE
  MOVI RB,0
ZERO_EQUALS_TRUE:
  PUSH RB,SP
  JPI NEXT

ONE_EQUALS:
  .N "1="
  .DATA ZERO_EQUALS
ONE_EQUALS_WA: .DATA ONE_EQUALS_CA
ONE_EQUALS_CA:
  POP RA,SP
  CMPI RA,1
  MOVI RB,1
  JRI[Z] ONE_EQUALS_TRUE
  MOVI RB,0
ONE_EQUALS_TRUE:
  PUSH RB,SP
  JPI NEXT

TWO_EQUALS:
  .N "2="
  .DATA ONE_EQUALS
TWO_EQUALS_WA: .DATA TWO_EQUALS_CA
TWO_EQUALS_CA:
  POP RA,SP
  CMPI RA,2
  MOVI RB,1
  JRI[Z] TWO_EQUALS_TRUE
  MOVI RB,0
TWO_EQUALS_TRUE:
  PUSH RB,SP
  JPI NEXT

SL:
  .N "<<"
  .DATA TWO_EQUALS
SL_WA: .DATA SL_CA
SL_CA:
  POP RB,SP
  POP RA,SP
  SL RA,RB
  PUSH RA,SP
  JPI NEXT

SR:
  .N ">>"
  .DATA SL
SR_WA: .DATA SR_CA
SR_CA:
  POP RB,SP
  POP RA,SP
  SR RA,RB
  PUSH RA,SP
  JPI NEXT

SL_ONE:
  .N "1<<"
  .DATA SR
SL_ONE_WA: .DATA SL_ONE_CA
SL_ONE_CA:
  POP RA,SP
  SLI RA,1
  PUSH RA,SP
  JPI NEXT

SR_ONE:
  .N "1>>"
  .DATA SL_ONE
SR_ONE_WA: .DATA SR_ONE_CA
SR_ONE_CA:
  POP RA,SP
  SRI RA,1
  PUSH RA,SP
  JPI NEXT

ALIGN:
  .N "ALIGN"
  .DATA SR_ONE
ALIGN_WA:
  .DATA ALIGN_CA
ALIGN_CA:
  POP RA,SP
  ADDI RA,1
  CLRI RA,0
  PUSH RA,SP
  JPI NEXT

DUP:
  .N "DUP"
  .DATA ALIGN
DUP_WA: .DATA DUP_CA
DUP_CA:
  POP RA,SP
  PUSH RA,SP
  PUSH RA,SP
  JPI NEXT

; ( 1 2 3 -- 3 1 2 )
ROT:
  .N "ROT"
  .DATA DUP
ROT_WA: .DATA ROT_CA
ROT_CA:
  POP R3,SP
  POP R2,SP
  POP R1,SP
  PUSH R3,SP
  PUSH R1,SP
  PUSH R2,SP
  JPI NEXT

; ( 1 2 3 -- 2 3 1 )
LROT:
  .N "LROT"
  .DATA ROT
LROT_WA: .DATA LROT_CA
LROT_CA:
  POP R3,SP
  POP R2,SP
  POP R1,SP
  PUSH R2,SP
  PUSH R3,SP
  PUSH R1,SP
  JPI NEXT

; ( xn .. x0 u -- xn .. x0 xu)
PICK:
  .N "PICK"
  .DATA LROT
PICK_WA: .DATA PICK_CA
PICK_CA:
  POP R0,SP
  MOV R1,SP
  ADD R1,R0
  ADD R1,R0 ; *2 to word-align
  ADDI R1,2 ; 
  LD R2,R1
  PUSH R2,SP
  JPI NEXT

SWAP:
  .N "SWAP"
  .DATA PICK
SWAP_WA: .DATA SWAP_CA
SWAP_CA:
  POP R0,SP
  POP R1,SP
  PUSH R0,SP
  PUSH R1,SP
  JPI NEXT

DROP:
  .N "DROP"
  .DATA SWAP
DROP_WA:
  .DATA DROP_CA
DROP_CA:
  POP RA,SP
  JPI NEXT

TWO_DROP:
  .N "2DROP"
  .DATA DROP
TWO_DROP_WA:
  .DATA TWO_DROP_CA
TWO_DROP_CA:
  POP RA,SP
  POP RA,SP
  JPI NEXT

OVER:
  .N "OVER"
  .DATA TWO_DROP
OVER_WA: .DATA OVER_CA
OVER_CA:
  POP RA,SP
  POP RB,SP
  PUSH RB,SP
  PUSH RA,SP
  PUSH RB,SP
  JPI NEXT

COPY:
; Copy words
; ( source-addr1 source-len dest-addr2 -- )
  .N "COPY"
  .DATA OVER
COPY_WA: .DATA COPY_CA
COPY_CA:
  .ALIAS R0,SRCA
  .ALIAS R1,SRCL
  .ALIAS R2,DEST
  .ALIAS R3,DATA
  POP DEST,SP
  POP SRCL,SP
  POP SRCA,SP
COPY_LOOP:
  CMPI SRCL,0
  JRI[Z] COPY_DONE
  LD DATA,SRCA
  ST DEST,DATA
  ADDI SRCA,2
  ADDI DEST,2
  SUBI SRCL,1
  JRI COPY_LOOP
COPY_DONE:
  JPI NEXT

CCOPY:
; Copy bytes 
  .N "CCOPY"
  .DATA COPY
CCOPY_WA: .DATA CCOPY_CA
CCOPY_CA:
  .ALIAS R0,SRCA
  .ALIAS R1,SRCL
  .ALIAS R2,DEST
  .ALIAS R3,DATA
  POP DEST,SP
  POP SRCL,SP
  POP SRCA,SP
CCOPY_LOOP:
  CMPI SRCL,0
  JRI[Z] COPY_DONE
  LD_B DATA,SRCA
  ST_B DEST,DATA
  ADDI SRCA,1
  ADDI DEST,1
  SUBI SRCL,1
  JRI COPY_LOOP
CCOPY_DONE:
  JPI NEXT

STRNCPY:
; ( source-addr dest-addr -- )
  .N "\"COPY"
  .DATA CCOPY
STRNCPY_WA: .DATA STRNCPY_CA
STRNCPY_CA:
  POP R0,SP
  POP R2,SP
  LD  R1,R0
  JRI CCOPY_LOOP

INDEX_I:
  .N "I"
  .DATA STRNCPY
INDEX_I_WA: .DATA INDEX_I_CA
INDEX_I_CA:
  POP RA,RS
  PUSH RA,RS
  PUSH RA,SP
  JPI NEXT

INDEX_J:
  .N "J"
  .DATA INDEX_I
INDEX_J_WA: .DATA INDEX_J_CA
INDEX_J_CA:
  LDX RA,RS+3 ; words
  PUSH RA,SP
  JPI NEXT

INDEX_K:
  .N "K"
  .DATA INDEX_J
INDEX_K_WA: .DATA INDEX_K_CA
INDEX_K_CA:
  LDX RA,RS+5 ; words
  PUSH RA,SP
  JPI NEXT

COMMA:
  .N ","
  .DATA INDEX_K
COMMA_WA: .DATA COMMA_CA
COMMA_CA:
  POP RA,SP
  LDI RB,%DICTIONARY_POINTER
  LD RB,RB
  ST RA,RB
  ADDI RB,2
  LDI RA,%DICTIONARY_POINTER
  ST RB,RA
  JPI NEXT

LEFT_SQUARE_BRACKET:
  .I "["
  .DATA COMMA
LSQB_WA: .DATA COLON
LSQB_CA:
  .DATA ZERO_WA
  .DATA MODE_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA

RIGHT_SQUARE_BRACKET:
  .N "]"
  .DATA LEFT_SQUARE_BRACKET
RSQB_WA: .DATA COLON
RSQB_CA:
  .DATA ONE_WA
  .DATA MODE_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA

BRACKET_TICK:
  .I "[']"
  .DATA RIGHT_SQUARE_BRACKET
BRACKET_TICK_WA: .DATA COLON
BRACKET_TICK_CA:
  .DATA STAR_HASH_WA
  .DATA STAR_HASH_WA
  .DATA COMMA_WA
  .DATA TICK_WA
  .DATA COMMA_WA
  .DATA STAR_SEMI_WA

BRACKET_CHAR:
  .I "[CHAR]"
  .DATA BRACKET_TICK
BRACKET_CHAR_WA: .DATA COLON
BRACKET_CHAR_CA:
  .DATA ASPACE_WA .DATA TOKEN_WA
  .DATA DP_AT_WA .DATA TWO_WA .DATA PLUS_WA
  .DATA C_AT_WA 
  .DATA STAR_HASH_WA .DATA STAR_HASH_WA
  .DATA COMMA_WA
  .DATA COMMA_WA
  .DATA STAR_SEMI_WA

ASPACE:           ; Forth word to push a space char to the stack
  .N "&sp;"
  .DATA BRACKET_CHAR
ASPACE_WA:
  .DATA ASPACE_CA
ASPACE_CA:
  MOVAI 0x20
  PUSH RA,SP
  JPI NEXT

DOT_ASPACE:           
  .N ".&sp;"
  .DATA ASPACE
DOT_ASPACE_WA:
  .DATA COLON
DOT_ASPACE_CA:
  .DATA ASPACE_WA
  .DATA EMIT_WA
  .DATA STAR_SEMI_WA

ZERO: .N "0" .DATA DOT_ASPACE 
ZERO_WA: .DATA ZERO_CA
ZERO_CA: 
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT

ONE: .N "1" .DATA ZERO 
ONE_WA: .DATA ONE_CA
ONE_CA: 
  MOVI RA,1
  PUSH RA,SP
  JPI NEXT

TWO: .N "2" .DATA ONE 
TWO_WA: .DATA TWO_CA
TWO_CA: 
  MOVI RA,2
  PUSH RA,SP
  JPI NEXT

THREE: .N "3" .DATA TWO 
THREE_WA: .DATA THREE_CA
THREE_CA: 
  MOVI RA,3
  PUSH RA,SP
  JPI NEXT

FOUR: .N "4" .DATA THREE 
FOUR_WA: .DATA FOUR_CA
FOUR_CA: 
  MOVI RA,4
  PUSH RA,SP
  JPI NEXT

FIVE: .N "5" .DATA FOUR 
FIVE_WA: .DATA FIVE_CA
FIVE_CA: 
  MOVI RA,5
  PUSH RA,SP
  JPI NEXT

SIX: .N "6" .DATA FIVE 
SIX_WA: .DATA SIX_CA
SIX_CA: 
  MOVI RA,6
  PUSH RA,SP
  JPI NEXT

SEVEN: .N "7" .DATA SIX 
SEVEN_WA: .DATA SEVEN_CA
SEVEN_CA: 
  MOVI RA,7
  PUSH RA,SP
  JPI NEXT

ONE_PLUS:
  .N "1+"
  .DATA SEVEN
ONE_PLUS_WA: .DATA ONE_PLUS_CA
ONE_PLUS_CA:
  POP RA,SP
  ADDI RA,1
  PUSH RA,SP
  JPI NEXT

TWO_PLUS:
  .N "2+"
  .DATA ONE_PLUS
TWO_PLUS_WA: .DATA TWO_PLUS_CA
TWO_PLUS_CA:
  POP RA,SP
  ADDI RA,2
  PUSH RA,SP
  JPI NEXT

FOUR_PLUS:
  .N "4+"
  .DATA TWO_PLUS
FOUR_PLUS_WA: .DATA FOUR_PLUS_CA
FOUR_PLUS_CA:
  POP RA,SP
  ADDI RA,4
  PUSH RA,SP
  JPI NEXT

ONE_MINUS:
  .N "1-"
  .DATA FOUR_PLUS
ONE_MINUS_WA: .DATA ONE_MINUS_CA
ONE_MINUS_CA:
  POP RA,SP
  SUBI RA,1
  PUSH RA,SP
  JPI NEXT

TWO_MINUS:
  .N "2-"
  .DATA ONE_MINUS
TWO_MINUS_WA: .DATA TWO_MINUS_CA
TWO_MINUS_CA:
  POP RA,SP
  SUBI RA,2
  PUSH RA,SP
  JPI NEXT

TWO_TIMES:
  .N "2*"
  .DATA TWO_MINUS
TWO_TIMES_WA: .DATA TWO_TIMES_CA
TWO_TIMES_CA:
  POP RA,SP
  SLI RA,1
  PUSH RA,SP
  JPI NEXT

TWO_DIV:
  .N "2/"
  .DATA TWO_TIMES
TWO_DIV_WA: .DATA TWO_DIV_CA
TWO_DIV_CA:
  POP RA,SP
  SRI RA,1
  PUSH RA,SP
  JPI NEXT

RP_AT:
  ; Copy the top of the return stack to the data stack
  .N "RP@"
  .DATA TWO_DIV
RS_AT_WA: .DATA RS_AT_CA
RS_AT_CA:
  POP RA,RS
  PUSH RA,RS
  PUSH RA,SP
  JPI NEXT

POP_RS:
  ; Pop the return stack frame
  ; Put the return address on the data stack
  .N "POP"
  .DATA RP_AT
POP_RS_WA: .DATA POP_RS_CA
POP_RS_CA:
  MOV RS,FP
  POP RA,RS
  POP FP,RS
  PUSH RA,SP
  JPI NEXT 

FP:
  ; Put the frame pointer on the data stack
  ; ( -- frame-pointer )
  .N "FP"
  .DATA POP_RS
FP_WA: .DATA FP_CA
FP_CA:
  PUSH FP,SP
  JPI NEXT

STAR_ALLOT_LOCALS:
; ( n -- )
; Allocate n words on the return stack
; Initialise to zero
  .N "*ALLOT-LOCALS"
  .DATA FP
STAR_ALLOT_LOCALS_WA: .DATA STAR_ALLOT_LOCALS_CA
STAR_ALLOT_LOCALS_CA:
  MOVI RA,0
  POP RB,SP
STAR_ALLOT_LOCALS_LOOP:
  CMPI RB,0
  JRI[Z] STAR_ALLOT_LOCALS_DONE
  PUSH RA,SP
  SUBI RB,1
  JRI STAR_ALLOT_LOCALS_LOOP
STAR_ALLOT_LOCALS_DONE:
  JPI NEXT

STAR_INIT_LOCALS:
; ( n -- )
; Allocate n words on the return stack
; Initialise from the data stack
  .N "*INIT-LOCALS"
  .DATA STAR_ALLOT_LOCALS
STAR_INIT_LOCALS_WA: .DATA STAR_INIT_LOCALS_CA
STAR_INIT_LOCALS_CA:

  .ALIAS R0,IDX
  .ALIAS R1,OFFSET
  .ALIAS R2,NUM
  .ALIAS R3,SPP
  .ALIAS R4,VAL

  POP NUM,SP
  MOV IDX,NUM
  MOV OFFSET,NUM
  ADD OFFSET,OFFSET

STAR_INIT_LOCALS_LOOP:
  CMPI IDX,0
  JRI[Z] STAR_INIT_LOCALS_DONE
  SUBI IDX,1
  MOV SPP,SP
  ADD SPP,OFFSET
  LD VAL,SPP
  PUSH VAL,RS
  SUBI OFFSET,2
  JRI STAR_INIT_LOCALS_LOOP
STAR_INIT_LOCALS_DONE:
  ADD NUM,NUM
  ADD SP,NUM
  JPI NEXT

R_FROM:
  .N "R>"
  .DATA STAR_INIT_LOCALS
R_FROM_WA:
  .DATA R_FROM_CA
R_FROM_CA:
  POP RA,RS
  PUSH RA,SP
  JPI NEXT

TO_R:
  .N ">R"
  .DATA R_FROM
TO_R_WA:
  .DATA TO_R_CA
TO_R_CA:
  POP RA,SP
  PUSH RS,RS
  JPI NEXT

R_DROP:
  .N "RDROP"
  .DATA TO_R
R_DROP_WA:
  .DATA R_DROP_CA
R_DROP_CA:
  POP RA,RS
  JPI NEXT

ENTRY:
  .N "ENTRY"
  .DATA R_DROP
ENTRY_WA:
  .DATA COLON
ENTRY_CA:
  .DATA CURRENT_WA
  .DATA AT_WA
  .DATA AT_WA
  .DATA STAR_SEMI_WA

DP:
  .N "DP"
  .DATA ENTRY
DP_WA: .DATA DP_CA
DP_CA:
  LDI RA,%DICTIONARY_POINTER
  PUSH RA,SP
  JPI NEXT

DP_STORE:
  .N "DP!"
  .DATA DP
DP_STORE_WA: .DATA DP_STORE_CA
DP_STORE_CA:
  LDI RA,%DICTIONARY_POINTER
  POP RB,SP
  ST RB,RA
  JPI NEXT

DP_AT:
  .N "DP@"
  .DATA DP_STORE
DP_AT_WA: .DATA DP_AT_CA
DP_AT_CA:
  LDI RA,%DICTIONARY_POINTER
  LD RA,RA
  PUSH RA,SP
  JPI NEXT

LBUF: ; ( -- lbuf-start lbuf-len )
  .N "LBUF"
  .DATA DP_AT
LBUF_WA: .DATA LBUF_CA
LBUF_CA:
  LDI RA,%LBUF_DATA
  PUSH RA,SP
  LDI RA,#LBUF_LEN
  PUSH RA,SP
  JPI NEXT

WA_TO_LA:
  .N "WA>LA"
  .DATA LBUF
WA_TO_LA_WA: .DATA WA_TO_LA_CA
WA_TO_LA_CA:
  ; ( wa -- ca )
  POP RA,SP
  MOV RB,RA
  LD RA,RB ; Length to A
  LDI R0, #HEADER_MASK
  AND RA,R0
  ADD RA,RB
  ADDI RA,3
  CLRI RA,0 ; Word-align
  PUSH RA,SP
  JPI NEXT

WA_TO_CA:
  .N "WA>CA"
  .DATA WA_TO_LA
WA_TO_CA_WA: .DATA WA_TO_CA_CA
WA_TO_CA_CA:
  ; ( wa -- ca )
  POP RA,SP
  MOV RB,RA
  LD RA,RB ; Length to A
  LDI R0, #HEADER_MASK
  AND RA,R0
  ADD RA,RB
  ADDI RA,5
  CLRI RA,0 ; Word-align
  PUSH RA,SP
  JPI NEXT

WA_TO_CB:
  .N "WA>CB"
  .DATA WA_TO_CA
WA_TO_CB_WA: .DATA WA_TO_CB_CA
WA_TO_CB_CA:
  ; ( wa -- cb )
  POP RA,SP
  MOV RB,RA
  LD RA,RB ; Length to A
  LDI R0, #HEADER_MASK
  AND RA,R0
  ADD RA,RB
  ADDI RA,7
  CLRI RA,0 ; Word-align
  PUSH RA,SP
  JPI NEXT

;  : CA>WA 
;    ( try to convert a CA to a Word address )
;    ( put a sanity check in place in case we can't find the WA )
;    2 - ( skip over the link word )
;    64
;    SWAP
;    BEGIN
;        SWAP DUP 0 = NOT 
;        ( addr count )
;        IF
;            ( OK to continue )
;            1 - ( addr count-- )
;            SWAP 
;            2 - DUP @ 0x8000 AND ( got to the header? )
;            ( count addr flag)
;            IF 1 ELSE 0 THEN
;        ELSE
;            DROP DROP 0 _UNKNOWN 0
;        THEN
;    ( count addr flag )
;    UNTIL
;    SWAP DROP
; ;

CA_TO_WA:
  .N "CA>WA"
  .DATA WA_TO_CB
CA_TO_WA_WA: .DATA COLON
CA_TO_WA_CA:
  .DATA STAR_HASH_WA .DATA 2 .DATA MINUS_WA
  .DATA STAR_HASH_WA .DATA 64 .DATA SWAP_WA
CA_TO_WA_LOOP:
  .DATA SWAP_WA .DATA DUP_WA .DATA STAR_HASH_WA .DATA 0
  .DATA EQUALS_WA .DATA NOT_WA
  .DATA STAR_IF_WA .DATA STAR_IF_LEAVE
  .DATA STAR_HASH_WA .DATA 1 .DATA MINUS_WA
  .DATA SWAP_WA
  .DATA STAR_HASH_WA .DATA 2 .DATA MINUS_WA 
  .DATA DUP_WA .DATA AT_WA
  .DATA STAR_HASH_WA .DATA 0x8000 .DATA AND_WA
  .DATA STAR_IF_WA .DATA CA_TO_WA_NOT_A_HEADER
  .DATA STAR_HASH_WA .DATA 1
  .DATA STAR_ELSE_WA .DATA CA_TO_WA_HEADER_THEN
CA_TO_WA_NOT_A_HEADER:
  .DATA STAR_HASH_WA .DATA 0
CA_TO_WA_HEADER_THEN:
  .DATA STAR_ELSE_WA .DATA CA_TO_WA_UNTIL
STAR_IF_LEAVE:
  .DATA DROP_WA .DATA DROP_WA
  .DATA STAR_HASH_WA .DATA 0
  .DATA STAR_LIT_WA .DATA 13 .SDATA "-- UNKNOWN --"
  .DATA STAR_HASH_WA .DATA 0
CA_TO_WA_UNTIL:
  .DATA STAR_UNTIL_WA
  .DATA CA_TO_WA_LOOP
  .DATA SWAP_WA .DATA DROP_WA
  .DATA STAR_SEMI_WA

CA:
; Returns the CA of the word currently being defined
  .N "CA"
  .DATA CA_TO_WA
CA_WA: .DATA COLON
CA_CA:
  .DATA ENTRY_WA
  .DATA WA_TO_CA_WA
  .DATA STAR_SEMI_WA

CREATE:
  .N "CREATE"
  .DATA CA
CREATE_WA: .DATA COLON
CREATE_CA:
  .DATA ENTRY_WA      ;( -- WA of last entry )
  .DATA ASPACE_WA
  .DATA TOKEN_WA
  .DATA TOKEN_LEN_WA      ;( .. -- WA LEN )
  
  .DATA DP_AT_WA       ;( .. -- WA LEN HERE )
  .DATA CURRENT_WA    
  .DATA AT_WA         ;( .. -- WA LEN HERE [ADDR OF CURRENT VOCAB] )
  .DATA STORE_WA      ;( .. -- WA LEN )

  ; Set the header bit in the word's length
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 0x8000
  .DATA OR_WA
  .DATA DP_AT_WA
  .DATA STORE_WA

  ; Bump the DP by the length of the token plus two for the length itself
  .DATA DP_AT_WA
  .DATA PLUS_WA       ; Add the length
  .DATA TWO_PLUS_WA
  .DATA ALIGN_WA      ; now points to link
  .DATA DP_WA
  .DATA STORE_WA      ; update the dictionary pointer

  ; Compile ENTRY
  .DATA COMMA_WA      ; point to the last entry
  .DATA DP_AT_WA
  .DATA TWO_PLUS_WA
  .DATA COMMA_WA      ; And point CA to here
  .DATA STAR_SEMI_WA

SEMICOLON:
; This is an immediate word
  .I ";"
  .DATA CREATE
SEMICOLON_WA: .DATA COLON
SEMICOLON_CA:
  .DATA STAR_HASH_WA .DATA STAR_SEMI_WA
  .DATA COMMA_WA
  .DATA STAR_HASH_WA
  .DATA 0
  .DATA MODE_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA

CURRENT:
  .N "CURRENT"
  .DATA SEMICOLON
CURRENT_WA:
  .DATA CURRENT_CA
CURRENT_CA:
  LDI RA,%CURRENT
  PUSH RA,SP
  JPI NEXT

CONTEXT:
  .N "CONTEXT"
  .DATA CURRENT
CONTEXT_WA:
  .DATA CONTEXT_CA
CONTEXT_CA:
  LDI RA,%CONTEXT
  PUSH RA,SP
  JPI NEXT

DEFINITIONS:
  .N "DEFINITIONS"
  .DATA CONTEXT
DEFINITIONS_WA: .DATA COLON
DEFINITIONS_CA:
  .DATA CONTEXT_WA
  .DATA AT_WA
  .DATA CURRENT_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA

CASTORE:
  .N "CA!"
  .DATA DEFINITIONS
CASTORE_WA:
  .DATA COLON
CASTORE_CA:
  .DATA ENTRY_WA
  .DATA WA_TO_CA_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA

HEADER_TO_MODE:
; ( headerWord -- modeBits )
  .N "HEADER>MODE"
  .DATA CASTORE
HEADER_TO_MODE_WA: .DATA HEADER_TO_MODE_CA
HEADER_TO_MODE_CA:
  POP RA,SP
  LDI RB,#HEADER_HEADER_BIT
  CLR RA,RB
  LDI RB,#HEADER_SCOPE_BITS
  SR RA,RB
  PUSH RA,SP
  JPI NEXT

Q_EXECUTE:
; ( wa -- flag )
  .N "?EXECUTE"
  .DATA HEADER_TO_MODE
Q_EXECUTE_WA:
  .DATA COLON

  ; This routine expects a NA on the stack from a successful SEARCH
  ; Words can be flagged with the immediate [15] and run-time [14] bits
  ; 000 - Normal word. Mode = 0 => Execute   Mode = 1 => Compile
  ; 001 - Immediate    Mode = 0 => Error     Mode = 1 => Execute
  ; 010 - Runtime only Mode = 0 => Execute   Mode = 1 => Error
  ; 011 - Executive    Mode = 0 => Execute   Mode = 1 => Execute
  ; 100 - Compile      Mode = 0 => Error     Mode = 1 => Compile
  ;
  ; Errors
  ; 2 0010 - MSG_IMMEDIATE_ONLY
  ; 5 0101 - MSG_RUNTIME_ONLY
  ; 8 1000 - MSG_COMPILE_ONLY
  ;
  ; Execute
  ; 0 0000
  ; 3 0011
  ; 4 0100
  ; 6 0110
  ; 7 0111
  ;
  ; Compile
  ; 1 0001
  ; 9 1001

Q_EXECUTE_CA:
  .DATA DUP_WA           ; ( addr - addr addr )
  .DATA AT_WA            ; (addr addr -- addr len )
  .DATA HEADER_TO_MODE_WA
  .DATA SL_ONE_WA        ; Get the bits in 2,1 (addr len -- addr (len>>13))
  .DATA MODE_WA
  .DATA AT_WA            ; Get the mode bit
  .DATA OR_WA            ; AS bit 0

  .DATA DUP_WA           ; ( addr bits -- addr bits bits )

; check for errors first
  .DATA STAR_HASH_WA .DATA 2 .DATA EQUALS_WA
  .DATA STAR_IF_WA .DATA Q_EXECUTE_5
  .DATA STAR_HASH_WA .DATA MSG_IMMEDIATE_ONLY
  .DATA STAR_ELSE_WA .DATA Q_EXECUTE_ERROR

Q_EXECUTE_5:
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 5 .DATA EQUALS_WA
  .DATA STAR_IF_WA .DATA Q_EXECUTE_8
  .DATA STAR_HASH_WA .DATA MSG_RUNTIME_ONLY
  .DATA STAR_ELSE_WA .DATA Q_EXECUTE_ERROR

Q_EXECUTE_8:
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 8 .DATA EQUALS_WA
  .DATA STAR_IF_WA .DATA Q_EXECUTE_1
  .DATA STAR_HASH_WA .DATA MSG_COMPILE_ONLY

Q_EXECUTE_ERROR:
  .DATA SWAP_WA .DATA DROP_WA
  .DATA SWAP_WA .DATA DOT_WORD_WA
  .DATA ASPACE_WA .DATA EMIT_WA
  .DATA TYPELN_WA
  .DATA ZERO_WA
  .DATA STAR_ELSE_WA
  .DATA Q_EXECUTE_EXIT

Q_EXECUTE_1:
  .DATA DUP_WA
  .DATA ONE_WA
  .DATA EQUALS_WA
  .DATA SWAP_WA
  .DATA STAR_HASH_WA .DATA 9
  .DATA EQUALS_WA
  .DATA OR_WA
  .DATA STAR_IF_WA .DATA Q_EXECUTE_EXECUTE

Q_EXECUTE_COMPILE:
  .DATA WA_TO_CA_WA
  .DATA COMMA_WA
  .DATA STAR_ELSE_WA 
  .DATA Q_EXECUTE_DONE  

Q_EXECUTE_EXECUTE:
  .DATA EXECUTE_WA

Q_EXECUTE_DONE:
  .DATA STAR_STACK_WA
  .DATA STAR_HASH_WA
  .DATA 1
Q_EXECUTE_EXIT:
  .DATA STAR_SEMI_WA

; ( -- num true ) | ( -- false )
Q_NUMBER:
  .N "?NUMBER"
  .DATA Q_EXECUTE
Q_NUMBER_WA: .DATA Q_NUMBER_CA
Q_NUMBER_CA:
  LDI RA,%DICTIONARY_POINTER
  LD RA,RA
  PUSH RA,SP
  JRIL SYSCALL_NUMBER
  JPI NEXT

EXECUTE:
  .N "EXECUTE"
  .DATA Q_NUMBER
EXECUTE_WA:
  .DATA EXECUTE_CA
EXECUTE_CA:
  POP WA,SP ; points to the WA
  MOV RA,WA
  LD RA,RA ; Get the length
  LDI RB,#HEADER_MASK ; flags
  AND RA,RB
  ADD WA,RA
  ADDI WA,5 ; Skip over the name and link
  CLRI WA,0 ; WOrd-align
  JPI RUN

; ( sep -- )
TOKEN:
  .N "TOKEN"
  .DATA EXECUTE
TOKEN_WA:
  .DATA TOKEN_CA
TOKEN_CA:
  ; Scans for tokens from the input line buffer
  ; The buffer is set up by INLINE
  ; LEN PTR CHARS
  ; Register usage:
  ; A - a character
  ; B - The separator
  ; R0 - Current pointer
  ; R1 - Length of this token
  ; R2 - End of the buffer
  ; R3 - scratch
  ; 

  ; Get the separator
  POP RB,SP

  MOVI R1,0 ; Token length
  MOVI R3,0

  LDI R0,%LBUF_IDX
  LD R0,R0

  LDI R2,%LBUF_END
  LD R2,R2

  CMP R2,R0
  ; at or past the end of the buffer already?
  JRI[Z] TOKEN_END
  JRI[C] TOKEN_END

  MOVAI 0x20   ; Put a space in A
  CMP RB,RA     ; Is the separator a space?
  JRI[NZ] TOKEN_TOK  ; No, so start seeking

TOKEN_SKIP:         ; Skip leading spaces
  CMP R2,R0         ; At the end of the buffer?
  JRI[Z] TOKEN_DONE
  LD_B RA,R0          ; Get the next char
  CMP RA,RB           ; Is it the separator?
  JRI[NZ] TOKEN_TOK
  ADDI R0,1
  JRI TOKEN_SKIP  ;

TOKEN_TOK:          ; Start searching for the end token here
  CMP R2,R0
  JRI[Z] TOKEN_DONE  ; Did we get to the end of the buffer?
  LD_B RA,R0
  CMP RA,RB
  JRI[Z] TOKEN_DONE
  CMPAI 0x0A        ; Or is this a carriage return?
  JRI[Z] TOKEN_DONE
  ADDI R0,1         ; idx++
  ADDI R1,1         ; len++
  JRI TOKEN_TOK

TOKEN_DONE:
  MOV R3,R1 ; Save for later
  CMPI R1,0
  JRI[Z] TOKEN_END
  ; Move the token to the end of the dictionary
  ; So ?SEARCH can access it
  LDI RA,%DICTIONARY_POINTER
  LD RB,RA    ; B Points to the dictionary
  ADDI RB,2  ; Bump the dictionary pointer
  SUB R0,R1 ; Reset the buffer pointer

TOKEN_MOVE:
  LD_B RA,R0
  ST_B RB,RA
  ADDI R0,1 ; Bump the buffer pointer
  ADDI RB,1 ; Bump the dictionary pointer
  SUBI R1,1 ; Decrement the length
  JRI[NZ] TOKEN_MOVE
  ;
  ; And we're done
  ; Save the current pointer
  LDI RA,%LBUF_IDX
  ADDI R0,1 ; Point past the terminator
  ST RA,R0

TOKEN_END:
  LDI RA,%DICTIONARY_POINTER
  LD RB,RA    ; B Points to the dictionary
  ST RB,R3   ; Save the length
  JPI NEXT

TOKEN_LEN:
  .N "TOKEN-LEN"
  .DATA TOKEN
TOKEN_LEN_WA: .DATA TOKEN_LEN_CA
TOKEN_LEN_CA:
  LDI RA,%DICTIONARY_POINTER
  LD RA,RA
  LD RA,RA
  PUSH RA,SP
  JPI NEXT

; INLINE - Read a line from the terminal
; Move it to the line buffer
; We'll just code this as a syscall for now 
; Returns a flag on the stack - false if no characters were read
; ( bufferAddress -- flag )
INLINE:
    .N "INLINE"
    .DATA TOKEN_LEN
INLINE_WA:
    .DATA INLINE_CA
INLINE_CA:
    ; Put the address and length of the line buffer on the stack
    LDI RA,%LBUF_IDX
    PUSH RA,SP
    LDI RA,#LBUF_LEN
    PUSH RA,SP
    JRIL SYSCALL_UART_READLINE
    JPI NEXT

; Push the literal following this word to the stack
; and jump over it
STAR_HASH:
; Compile time only
    .I "*#"
    .DATA INLINE ; Link to INLINE
STAR_HASH_WA:
    .DATA STAR_HASH_CA
STAR_HASH_CA:
    LD RA,RI
    PUSH RA,SP
    ADDI RI,2
    JPI NEXT

BEGIN:
; Compile time only
  .I "BEGIN"
  .DATA STAR_HASH
BEGIN_WA: .DATA BEGIN_CA
BEGIN_CA:
  LDI RA,%DICTIONARY_POINTER
  LD RA,RA ; current DP
  PUSH RA,SP
  JPI NEXT

UNTIL:
; Compile time only
  .I "UNTIL"
  .DATA BEGIN
UNTIL_WA: .DATA COLON
UNTIL_CA:
  .DATA STAR_HASH_WA .DATA STAR_UNTIL_WA
  .DATA COMMA_WA
  .DATA COMMA_WA
  .DATA STAR_SEMI_WA


STAR_UNTIL:
; Compile only
  .X "*UNTIL"
  .DATA UNTIL
STAR_UNTIL_WA: .DATA STAR_UNTIL_CA
STAR_UNTIL_CA:
  POP RA,SP ; get the flag
  CMPI RA,0
  JRI[NZ] STAR_UNTIL_DONE
  LD RI,RI ; Jump back to the begin
  JPI NEXT
STAR_UNTIL_DONE:
  ADDI RI,2
  JPI NEXT

CASE:
  .I "CASE"
  .DATA STAR_UNTIL
CASE_WA: .DATA COLON
CASE_CA: 
  .DATA STAR_HASH_WA .DATA 0
  .DATA STAR_SEMI_WA

; CASE someValue v1 OF ... ENDOF v2 OF ... ENDOF ESAC 
; code *OF a1 ... a1:*ENDOF ax *OF a3 ... a3:*ENDOF ax ax:*ESAC
;         (a0)                    (a2)
; CASE 0 ; Number of OF clauses to the stack
;
; OF    -> ' *OF , HERE ( push here to the stack ) SWAP 1+ ( increment number of clauses )
; ENDOF -> HERE SWAP ! ' *ENDOF , HERE 2 ALLOT 
; 
; OF ( 0 -- a0 1 )             ENDOF ( a1 1 )
; OF ( a1 1 -- a1 2 a2 )       ENDOF ( a1 a3 2 )
; OF ( a1 a3 2 -- a1 a3 3 a4 ) ENDOF ( a1 a3 a5 3 )

CASE_OF:
  .I "OF"
  .DATA CASE
CASE_OF_WA: .DATA CASE_OF_CA
CASE_OF_CA:
; R0 - Address of *OF
; R1 - Address of DP
; R2 - value of DP
; R3 - number of clauses
  .ALIAS R0,*OF
  .ALIAS R1,DP
  .ALIAS R2,*DP
  .ALIAS R3,NUM

  POP NUM,SP
  ADDI NUM,1
  LDI *OF,STAR_OF_WA
  LDI DP,%DICTIONARY_POINTER
  LD *DP,DP
  ST *DP,*OF ; Compile *OF
  ADDI *DP,2 ; point to location of jump word
  PUSH *DP,SP  ; save the location
  PUSH NUM,SP  ; Number of clauses
  ADDI *DP,2 ; next location for the definition
  ST DP,*DP
  JPI NEXT  


ENDOF:
  .I "ENDOF"
  .DATA CASE_OF
ENDOF_WA:
  .DATA ENDOF_CA
ENDOF_CA:
  ; TOS contains the location of the word to use for the IF relative jump
  ; R0 - Address of DP
  ; R1 - Value of DP (HERE)
  ; R2 - location of jump address
  POP R3,SP ; Number of clauses
  POP R2,SP ; Address of previous *OF + 2
  LDI R0,%DICTIONARY_POINTER
  LD R1,R0
  ADDI R1,4
  ST R2,R1   ; Save it in the jump location
  LDI RA,STAR_OF_ENDOF_WA
  SUBI R1,4
  ST R1,RA  ; Compile to the current definition
  ADDI R1,2
  PUSH R1,SP
  PUSH R3,SP
  ADDI R1,2
  ST R0,R1
  JPI NEXT

ESAC:
  .I "ESAC"
  .DATA ENDOF
ESAC_WA: .DATA ESAC_CA
ESAC_CA:
  ; number of jump locations to fill in is TOS
  POP R0,SP
  LDI R1,%DICTIONARY_POINTER
  LD R1,R1
  LDI R2,STAR_ESAC_WA
  ST R1,R2
  ADDI R1,2
  LDI R2,%DICTIONARY_POINTER
  ST R2,R1
  SUBI R1,2

ESAC_LOOP:
  AND R0,R0
  JRI[Z] ESAC_LOOP_DONE
  SUBI R0,1
  POP R2,SP
  ST R2,R1
  JRI ESAC_LOOP

ESAC_LOOP_DONE:
  JPI NEXT


STAR_OF:
  .X "*OF"
  .DATA ESAC
STAR_OF_WA:
  .DATA STAR_OF_CA
STAR_OF_CA:
; ( v1 v2 -- v1 )
  POP RA,SP 
  POP RB,SP
  CMP RA,RB
  JRI[Z] STAR_OF_RUN
  PUSH RB,SP
  LD RI,RI ; Jump to after the *ENDOF
  JPI NEXT
STAR_OF_RUN:
  ADDI RI,2
  JPI NEXT

STAR_OF_ENDOF:
  .X "*OF_ENDOF"
  .DATA STAR_OF
STAR_OF_ENDOF_WA:
  .DATA STAR_OF_ENDOF_CA
STAR_OF_ENDOF_CA:
  LD RI,RI ; Jump to the *ESAC
  JPI NEXT

STAR_ESAC:
  .N "*ESAC"
  .DATA STAR_OF_ENDOF
STAR_ESAC_WA: .DATA STAR_ESAC_CA
STAR_ESAC_CA:
  JPI NEXT


IF:
  .I "IF"
  .DATA STAR_ESAC
IF_WA:
  .DATA IF_CA
IF_CA:
; R0 - Address of *IF
; R1 - Address of DP
; R2 - value of DP
  LDI R0,STAR_IF_WA
  LDI R1,%DICTIONARY_POINTER
  LD R2,R1
  ST R2,R0 ; Compile *IF
  ADDI R2,2 ; point to location of jump word
  PUSH R2,SP  ; save the location
  ADDI R2,2 ; next location for the definition
  ST R1,R2
  JPI NEXT

ELSE:
  .I "ELSE"
  .DATA IF
ELSE_WA:
  .DATA ELSE_CA
ELSE_CA:
  ; TOS contains the location of the word to use for the IF relative jump
  ; R0 - Address of DP
  ; R1 - Value of DP (HERE)
  ; R2 - location of jump address
  POP R2,SP
  LDI R0,%DICTIONARY_POINTER
  LD R1,R0
  ADDI R1,4
  ST R2,R1   ; Save it in the jump location
  LDI RA,STAR_ELSE_WA
  SUBI R1,4
  ST R1,RA  ; Compile *ELSE to the current definition
  ADDI R1,2
  PUSH R1,SP
  ADDI R1,2
  ST R0,R1
  JPI NEXT

THEN:
  .I "THEN"
  .DATA ELSE
THEN_WA:
  .DATA THEN_CA
THEN_CA:
  ; TOS contains the location of the word to use for the IF/ELSE  jump
  POP RA,SP
  LDI RB,%DICTIONARY_POINTER ; Current dictionary location to B
  LD RB,RB
  ST RB,RA   ; Save it in the jump location
  JPI NEXT  

STAR_IF:
  .X "*IF"
  .DATA THEN
STAR_IF_WA:
  .DATA STAR_IF_CA
STAR_IF_CA:
  POP RA,SP ; get the flag
  CMPI RA,0
  JRI[Z] STAR_ELSE_CA
  ADDI RI,2
  JPI NEXT

STAR_ELSE:
  .X "*ELSE"
  .DATA STAR_IF
STAR_ELSE_WA:
  .DATA STAR_ELSE_CA
STAR_ELSE_CA:
  LD RI,RI
  JPI NEXT

DO:
  .I "DO"
  .DATA STAR_ELSE
DO_WA: .DATA COLON
DO_CA:
  ; Compile *DO
  .DATA STAR_HASH_WA .DATA STAR_DO_WA
  .DATA COMMA_WA
  ; Push Here to the stack so LOOP can compile it later
  .DATA DP_AT_WA
  .DATA ZERO_WA ; Flag to say it's a normal loop
  .DATA STAR_SEMI_WA

QDO:
  .I "?DO"
  .DATA DO
QDO_WA: .DATA COLON
QDO_CA:
  ; Compile *QDO
  .DATA STAR_HASH_WA .DATA STAR_QDO_WA
  .DATA COMMA_WA
  ; Push Here to the stack so LOOP can compile it later
  .DATA DP_AT_WA
  .DATA ONE_WA ; Flag to say it's a ?DO loop
  ; Reserve space for the jump address
  .DATA ZERO_WA .DATA COMMA_WA
  .DATA STAR_SEMI_WA

STAR_DO:
  .X "*DO"
  .DATA QDO
STAR_DO_WA: .DATA STAR_DO_CA
STAR_DO_CA:
  POP RA,SP
  POP RB,SP
  PUSH RB,RS
  PUSH RA,RS
  JPI NEXT

STAR_QDO:
  .X "*QDO"
  .DATA STAR_DO
STAR_QDO_WA: .DATA STAR_QDO_CA
STAR_QDO_CA:
  POP RA,SP
  POP RB,SP
  CMP RB,RA
  JRI[Z] STAR_QDO_DONT
  JRI[C] STAR_QDO_DONT
  PUSH RB,SP
  PUSH RA,SP
  ADDI RI,2
  JRI STAR_DO_CA
STAR_QDO_DONT:
  LD RI,RI
  JPI NEXT

LOOP:
  .I "LOOP"
  .DATA STAR_QDO
LOOP_WA: .DATA COLON
LOOP_CA:
  .DATA STAR_HASH_WA
  .DATA STAR_LOOP_WA
  .DATA COMMA_WA
  .DATA STAR_IF_WA ; Normal or ?DO
  .DATA LOOP_NORMAL
  .DATA DUP_WA
  .DATA DP_AT_WA
  .DATA TWO_PLUS_WA
  .DATA SWAP_WA
  .DATA STORE_WA
  .DATA TWO_PLUS_WA
LOOP_NORMAL:
  .DATA COMMA_WA ; and compile the return address off the stack
  .DATA STAR_SEMI_WA

PLUS_LOOP:
  .I "+LOOP"
  .DATA LOOP
PLUS_LOOP_WA: .DATA COLON
PLUS_LOOP_CA:
  .DATA STAR_HASH_WA
  .DATA STAR_PLUS_LOOP_WA
  .DATA COMMA_WA
  .DATA STAR_IF_WA ; Normal or ?DO
  .DATA PLUS_LOOP_NORMAL
  .DATA DUP_WA
  .DATA DP_AT_WA
  .DATA TWO_PLUS_WA
  .DATA SWAP_WA
  .DATA STORE_WA
  .DATA TWO_PLUS_WA
PLUS_LOOP_NORMAL:
  .DATA COMMA_WA ; and compile the return address off the stack
  .DATA STAR_SEMI_WA

MINUS_LOOP:
  .I "-LOOP"
  .DATA PLUS_LOOP
MINUS_LOOP_WA: .DATA COLON
MINUS_LOOP_CA:
  .DATA STAR_HASH_WA
  .DATA STAR_MINUS_LOOP_WA
  .DATA COMMA_WA
  .DATA STAR_IF_WA ; Normal or ?DO
  .DATA MINUS_LOOP_NORMAL
  .DATA DUP_WA
  .DATA DP_AT_WA
  .DATA TWO_PLUS_WA
  .DATA SWAP_WA
  .DATA STORE_WA
  .DATA TWO_PLUS_WA
MINUS_LOOP_NORMAL:
  .DATA COMMA_WA ; and compile the return address off the stack
  .DATA STAR_SEMI_WA

STAR_LOOP:
  .X "*LOOP"
  .DATA MINUS_LOOP
STAR_LOOP_WA: .DATA STAR_LOOP_CA
STAR_LOOP_CA:
  POP RA,RS; current index
  POP RB,RS; end
  ADDI RA,1
STAR_CHECK_LOOP:
  CMP RA,RB 
  JRI[C] STAR_LOOP_MORE ; Index not exceeded
  ; Index exceeded, loop is over
  ADDI RI,2
  JPI NEXT
STAR_LOOP_MORE:
  PUSH RB,RS
  PUSH RA,RS
  LD RI,RI
  JPI NEXT

STAR_PLUS_LOOP:
  .X "*+LOOP"
  .DATA STAR_LOOP
STAR_PLUS_LOOP_WA: .DATA STAR_PLUS_LOOP_CA
STAR_PLUS_LOOP_CA:
  POP RA,RS
  POP RB,RS
  POP R0,SP
  ADD RA,R0
  JRI STAR_CHECK_LOOP
  ; No return address

STAR_MINUS_LOOP:
  .X "*-LOOP"
  .DATA STAR_PLUS_LOOP
STAR_MINUS_LOOP_WA: .DATA STAR_MINUS_LOOP_CA
STAR_MINUS_LOOP_CA:
; 0 9 DO stuff 1 -LOOP

  .ALIAS RA,INDEX
  .ALIAS RB,LIMIT
  .ALIAS R0,INCREMENT

  POP INDEX,RS
  POP LIMIT,RS
  POP INCREMENT,SP
  SUB INDEX,INCREMENT
  CMP LIMIT,INDEX
  JRI[Z] STAR_LOOP_MORE ; Index not exceeded
  MOV R0,LIMIT
  XOR R0,INDEX ; Compare signs
  BITI R0,15
  JRI[Z] STAR_MINUS_LOOP_SAME_SIGN
  ; Signs are different, so the negative one is <
  BITI RA,15
  JRI[Z] STAR_LOOP_MORE
  JRI STAR_MINUS_LOOP_DONE

STAR_MINUS_LOOP_SAME_SIGN:
  ; We can just do a normal compare
  CMP RA,RB
  JRI[NC] STAR_LOOP_MORE

STAR_MINUS_LOOP_DONE:
  ; Index exceeded, loop is over
  ADDI RI,2
  JPI NEXT

DONE:
  .N "DONE"
  .DATA STAR_MINUS_LOOP
DONE_WA: .DATA DONE_CA
DONE_CA:
  ; Make the loop index equal to the end value
  ; on the return stack
  MOV R0,RS
  ADDI R0,4
  LD R1,R0
  SUBI R0,2
  ST R0,R1
  JPI NEXT

SP:
  .N "SP@"
  .DATA DONE
SP_WA: .DATA SP_CA
SP_CA:
  PUSH SP,SP
  JPI NEXT

RP:
  .N "RP"
  .DATA SP
RP_WA: .DATA RP_CA
RP_CA:
  PUSH RS,SP
JPI NEXT

DOT_LOCATION:
; ( addr -- )
; Print the address and contents in HEX and ASCII
  .N ".LOCATION"
  .DATA RP
DOT_LOCATION_WA: .DATA COLON
DOT_LOCATION_CA:
  .DATA DUP_WA .DATA AT_WA ; data
  .DATA SWAP_WA            ; address
  .DATA DOT_WA
  .DATA DOT_ASPACE_WA
  .DATA DUP_WA
  .DATA DOT_TWO_BYTES_WA
  .DATA DOT_TWO_CHARS_WA
  .DATA CRET_WA
  .DATA STAR_SEMI_WA

DOT_MEM:
; Print the block of memory in the order given
; ( start end -- )
  .N ".MEM"
  .DATA DOT_LOCATION
DOT_MEM_WA: .DATA COLON
DOT_MEM_CA:
  .DATA D_DUP_WA
  .DATA GT_WA
  .DATA STAR_IF_WA 
  .DATA DOT_MEM_DOWN
  
DOT_MEM_UP:
  .DATA STAR_DO_WA
DOT_MEM_UP_LOOP:
  .DATA INDEX_I_WA .DATA DOT_LOCATION_WA
  .DATA TWO_WA
  .DATA STAR_PLUS_LOOP_WA .DATA DOT_MEM_UP_LOOP
  .DATA STAR_ELSE_WA .DATA DOT_MEM_DONE

DOT_MEM_DOWN:
  .DATA STAR_DO_WA
DOT_MEM_DOWN_LOOP: 
  .DATA INDEX_I_WA .DATA DOT_LOCATION_WA
  .DATA TWO_WA
  .DATA STAR_MINUS_LOOP_WA .DATA DOT_MEM_DOWN_LOOP
  .DATA STAR_ELSE_WA .DATA DOT_MEM_DONE

DOT_MEM_DONE:
  .DATA STAR_SEMI_WA

DUMP:
; ( start-addr len -- )
  .N "DUMP"
  .DATA DOT_MEM
DUMP_WA: .DATA COLON
DUMP_CA:
  .DATA OVER_WA
  .DATA PLUS_WA
  .DATA SWAP_WA
  .DATA DOT_MEM_WA
  .DATA STAR_SEMI_WA

; Print the data stack
DOT_SP:
  .N ".SP"
  .DATA DUMP
DOT_SP_WA: .DATA COLON
  .DATA SP_WA
  .DATA TWO_WA .DATA PLUS_WA
  .DATA SPTOP_WA
  .DATA DOT_MEM_WA
  .DATA STAR_SEMI_WA

; Print the return stack
DOT_RS:
  .N ".RS"
  .DATA DOT_SP
DOT_RS_WA: .DATA COLON
  .DATA RP_WA
  .DATA TWO_WA .DATA PLUS_WA
  .DATA RSTOP_WA
  .DATA DOT_MEM_WA
  .DATA STAR_SEMI_WA

; Patch - fixup the dictionary to remove any half-compiled words
PATCH:
  .N "PATCH"
  .DATA DOT_RS
PATCH_WA: .DATA COLON
PATCH_CA:
  .DATA MODE_WA
  .DATA AT_WA
  .DATA STAR_IF_WA
  .DATA PATCH_DONE
  .DATA CURRENT_WA
  .DATA AT_WA .DATA AT_WA
  .DATA DUP_WA
  .DATA DP_STORE_WA ; Reset the dictionary pointer
  .DATA WA_TO_LA_WA .DATA AT_WA
  .DATA CURRENT_WA .DATA AT_WA .DATA STORE_WA
PATCH_DONE:
  .DATA RESTART_WA
  .DATA STAR_SEMI_WA

OUTER:
    .N "OUTER"
    .DATA PATCH
OUTER_WA:
    .DATA COLON
OUTER_CA:
    .DATA STAR_HASH_WA
    .DATA MSG_HELLO
    .DATA TYPE_WA

OUTER_LOOP:
    .DATA CRET_WA
    .DATA STAR_HASH_WA
    .DATA MSG_PROMPT
    .DATA TYPE_WA
OUTER_LOOP_READ:
    .DATA INLINE_WA
    ; 0 means nothing was available so loop with no prompt
    .DATA DUP_WA
    .DATA ZERO_EQUALS_WA
    .DATA STAR_IF_WA
    .DATA OUTER_LOOP_HAS_INPUT
    .DATA DROP_WA
    .DATA STAR_ELSE_WA
    .DATA OUTER_LOOP_READ
OUTER_LOOP_HAS_INPUT:
    .DATA TWO_EQUALS_WA
    ; 2 means empty input was received, so loop with  prompt
    .DATA STAR_IF_WA
    .DATA OUTER_LOOP_PROCESS
    .DATA STAR_ELSE_WA
    .DATA OUTER_LOOP
OUTER_LOOP_PROCESS:
    .DATA PROCESS_TOKENS_WA
    .DATA DROP_WA
    .DATA STAR_ELSE_WA
    .DATA OUTER_LOOP
    .DATA STAR_SEMI_WA

PROCESS_TOKENS:
; ( -- success )
    .N "PROCESS-TOKENS"
    .DATA OUTER
PROCESS_TOKENS_WA: .DATA COLON
PROCESS_TOKENS_CA:
PROCESS_TOKENS_LOOP:
    .DATA ASPACE_WA
    .DATA TOKEN_WA
    .DATA TOKEN_LEN_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_EXIT_SUCCEEDED ; Just jump back to get another line if no more tokens
    .DATA SEARCH_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_NOT_A_WORD
    .DATA Q_EXECUTE_WA ; If the execute failed, discard the rest of the line
    .DATA NOT_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_LOOP
    .DATA PATCH_WA
    .DATA STAR_ELSE_WA
    .DATA PROCESS_TOKENS_EXIT_FAILED

PROCESS_TOKENS_NOT_A_WORD:
    .DATA Q_NUMBER_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_NOT_A_NUMBER
    ; Number is on the stack. 
    ; If we're in compile mode, enclose it
    .DATA MODE_WA
    .DATA AT_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_NUM_TO_STACK
    .DATA STAR_HASH_WA
    .DATA STAR_HASH_WA ; push the literal handler to the stack
    .DATA COMMA_WA     ; enclose it
    .DATA COMMA_WA     ; and he number

PROCESS_TOKENS_NUM_TO_STACK:
    .DATA STAR_ELSE_WA
    .DATA PROCESS_TOKENS_LOOP ; Leave the number on the stack and loop

PROCESS_TOKENS_NOT_A_NUMBER:
; Is there a token handler installed?
    .DATA Q_TOKEN_HANDLER_WA
    .DATA NOT_WA
    .DATA STAR_IF_WA .DATA PROCESS_TOKENS_EXIT_SUCCEEDED
    .DATA STAR_HASH_WA
    .DATA MSG_UNKNOWN_TOKEN
    .DATA TYPE_WA
    .DATA DP_WA
    .DATA AT_WA
    .DATA TYPE_WA

PROCESS_TOKENS_EXIT_FAILED:
  .DATA ZERO_WA
  .DATA STAR_ELSE_WA
  .DATA PROCESS_TOKENS_EXIT

PROCESS_TOKENS_EXIT_SUCCEEDED:
  .DATA ONE_WA

PROCESS_TOKENS_EXIT:
    .DATA STAR_SEMI_WA

; ( addr -- len )
WORD_LEN:
  .N "WORD-LEN"
  .DATA PROCESS_TOKENS
WORD_LEN_WA: .DATA WORD_LEN_CA
WORD_LEN_CA:
  POP RA,SP
  LD RA,RA
  LDI RB,#HEADER_MASK
  AND RA,RB
  PUSH RA,SP
  JPI NEXT  

DOT_WORD:
  .N ".WORD"
  .DATA WORD_LEN
DOT_WORD_WA: .DATA DOT_WORD_CA
DOT_WORD_CA:
  ; ( wordAddr -- )
  ; R0 - addr -> idx
  ; R1 - len
  POP R0,SP
  LD R1,R0 ; Len to R1
  LDI RB,#HEADER_MASK
  AND R1,RB
  ADDI R0,2 ; point to word
DOT_WORD_LOOP:
  LD_B R2,R0
  MOV RA,R2
  JRIL SYSCALL_UART_TX_BYTE
  ADDI R0,1
  SUBI R1,1
  JRI[NZ] DOT_WORD_LOOP
  JPI NEXT

NEXT_WORD:
  .N "NEXT-WORD"
  .DATA DOT_WORD
NEXT_WORD_WA: .DATA COLON
NEXT_WORD_CA:
  ; ( addr -- addr )
  ; DUP @ + 2+ ALIGN @
  .DATA DUP_WA
  .DATA AT_WA
  .DATA STAR_HASH_WA
  .DATA 0x0fff
  .DATA AND_WA
  .DATA PLUS_WA
  .DATA TWO_PLUS_WA
  .DATA ALIGN_WA
  .DATA AT_WA
  .DATA STAR_SEMI_WA


CRET:
  .N "CRET"
  .DATA NEXT_WORD
CRET_WA: .DATA CRET_CA
CRET_CA:
  LDI RA,0x0a
  JRIL SYSCALL_UART_TX_BYTE
  JPI NEXT

DOT_WORD_NEXT:
; ( wa -- wa wa ) or ( wa -- 0 )
; Print the word at wa and walk up to the  next
; word if it exists

  .N ".WORD-NEXT?"
  .DATA CRET
DOT_WORD_NEXT_WA: .DATA COLON
DOT_WORD_NEXT_CA:
  .DATA DUP_WA
  .DATA DOT_WORD_WA
  .DATA ASPACE_WA .DATA EMIT_WA
  .DATA NEXT_WORD_WA
  .DATA DUP_WA 
  .DATA STAR_IF_WA ; If there is a word
  .DATA DOT_WORD_NEXT_DONE
  .DATA DUP_WA     ; Then duplicate it as a flag
DOT_WORD_NEXT_DONE:
  .DATA STAR_SEMI_WA

WORDS:
; List all the defined words
  .N "WORDS"
  .DATA DOT_WORD_NEXT
WORDS_WA: .DATA COLON
WORDS_CA:
  .DATA CONTEXT_WA
  .DATA AT_WA
  .DATA AT_WA
WORDS_LOOP:
  .DATA DUP_WA
  .DATA VAR_FENCE_WA .DATA AT_WA
  .DATA EQUALS_WA .DATA STAR_IF_WA .DATA WORDS_LOOP_PRINT
  .DATA CRET_WA
  .DATA STAR_LIT_WA
  .DATA 17
  .SDATA "----- FENCE -----"
  .DATA CRET_WA
WORDS_LOOP_PRINT:
  .DATA DOT_WORD_NEXT_WA
  .DATA NOT_WA
  .DATA STAR_UNTIL_WA .DATA WORDS_LOOP
  .DATA STAR_SEMI_WA

COMPARE: ; ( c-addr1 c-addr2 -- result )
; Compare the strings
; result = -1 if str1 < str2
; result = 0 if strings are equal
; result = 1 if str1 > str2
  .N "COMPARE"
  .DATA WORDS
COMPARE_WA: .DATA COMPARE_CA
COMPARE_CA:
  .ALIAS R0,S1
  .ALIAS R1,L1
  .ALIAS R2,S2
  .ALIAS R3,L2
  .ALIAS R4,IDX
  .ALIAS R5,L
  .ALIAS R6,C1
  .ALIAS R7,C2

  POP S1,SP
  POP S2,SP
  LD L1,S1
  ADDI S1,3
  LD L2,S2
  ADDI S2,2
  MOV L,L1
  CMP L2,L1
  JRI[NC] COMPARE_LOOP
  MOV L,L2
COMPARE_LOOP:
; WHILE IDX < L
  CMP IDX,L
  JRI[NC] COMPARE_LOOP_DONE
  POP_B C1,S1
  POP_B C2,S2
  CMP C1,C2
  ; c1 < c2 return -1
  JRI[NC] COMPARE_LOOP_C1_GTE_C2
  LDI R0,-1
  PUSH R0,SP
  JRI NEXT
COMPARE_LOOP_C1_GTE_C2:
  CMP C2,C1
  JRI[Z] COMPARE_LOOP_C1_EQ_C2
  MOVI R0,1
  PUSH R0,SP
  JRI NEXT
COMPARE_LOOP_C1_EQ_C2:
  ADDI IDX,1
  JRI COMPARE_LOOP

COMPARE_LOOP_DONE:
  CMP L1,L2
  JRI[NZ] COMPARE_UNEQUAL_LENGTHS
  MOVI R0,0
  PUSH R0,SP
  JRI NEXT  

COMPARE_UNEQUAL_LENGTHS:
  CMP L2,L1
  JRI[NC] COMPARE_L1_LT_L2
  MOVI R0,1
  PUSH R0,SP
  JRI NEXT

COMPARE_L1_LT_L2:
  LDI R0,-1
  PUSH R0,SP
  JRI NEXT


; Search the dictionary for the current token
; Searches the vocabulary pointed to by CURRENT
; Return the WA on the stack if a match is found, or zero
; ( -- addr-or-zero )
SEARCH:
    .N "SEARCH"
    .DATA COMPARE
SEARCH_WA:
    .DATA SEARCH_CA
SEARCH_CA:

  .ALIAS R0,*DP
  .ALIAS R1,LENA
  .ALIAS R2,*WORD   ; The word we're looking for (the token at DP)
  .ALIAS R3,LENB
  .ALIAS R4,*CANDIDATE   ; The word we're currently testing (the word at WA)
  .ALIAS R5,SWA  ; Search word address
  .ALIAS R6,*TOK ; DP+2
  .ALIAS R7,IDX  ; Loop counter

  LDI *DP,%DICTIONARY_POINTER
  LD *DP,*DP

  ; Token length
  LD LENA,*DP
  ; Bump I to point to first char
  ADDI *DP,2
  MOV *TOK,*DP ; Keep a backup copy for each trip round the loop

  ; Use CA R2 to point to the current word
  LDI SWA,%CONTEXT
  LD SWA,SWA
  LD SWA,SWA

SEARCH_NEXT:
  LD LENB,SWA  ; get the length of the word
  LDI RA,#HEADER_MASK
  AND LENB,RA
  CMP LENB,LENA ; Same as the token?
  JRI[Z] SEARCH_COMPARE
  ; Not the same, move to the next word
SEARCH_COMPARE_FAIL:
  ADD SWA,LENB
  ADDI SWA,3 ; CA now points to the link address
  CLRI SWA,0  ; make sure it's a word address
  LD SWA,SWA ; Now point to the next word
  AND SWA,SWA ; Is it zero?
  JRI[NZ] SEARCH_NEXT

SEARCH_EXIT:
  ; Not found so leave the bufferr address zero on the stack and exit
  MOVI RA,0
  PUSH RA,SP
  JPI NEXT

SEARCH_COMPARE:
  ; Test the strings for equality
  MOV *WORD,*TOK
  MOV *CANDIDATE,SWA
  ADDI *CANDIDATE,2 ; Point to the string
  MOV IDX,LENA ; Length to R4 for the counter

SEARCH_COMPARE_LOOP:
  LD_B RA,*WORD
  LD_B RB,*CANDIDATE
  CMP RA,RB
  JRI[NZ] SEARCH_COMPARE_FAIL
  ADDI *WORD,1
  ADDI *CANDIDATE,1
  SUBI IDX,1
  JRI[NZ] SEARCH_COMPARE_LOOP
SEARCH_COMPARE_FOUND:
  PUSH SWA,SP ; Name address to the stack
  MOVI RA,1
  PUSH RA,SP   ; And a true flag
  JPI NEXT

TWO_DOTS: ; This is the public COLON routine
  .N ":"
  .DATA SEARCH
TWO_DOTS_WA: .DATA COLON
TWO_DOTS_CA:
  .DATA CURRENT_WA
  .DATA AT_WA
  .DATA CONTEXT_WA
  .DATA STORE_WA
  .DATA CREATE_WA
  .DATA STAR_HASH_WA
  .DATA COLON
  .DATA CASTORE_WA
  .DATA STAR_HASH_WA
  .DATA 1
  .DATA MODE_WA
  .DATA STORE_WA
  .DATA STAR_SEMI_WA


LIT:
  .I ".\""
  .DATA TWO_DOTS
LIT_WA: .DATA COLON
LIT_CA:
  .DATA STAR_HASH_WA .DATA STAR_LIT_WA 
  .DATA COMMA_WA
  .DATA STAR_HASH_WA .DATA 0x22
  .DATA TOKEN_WA
  .DATA TOKEN_LEN_WA
  .DATA TWO_PLUS_WA
  .DATA ALIGN_WA
  .DATA DP_WA
  .DATA PLUS_STORE_WA
  .DATA STAR_SEMI_WA

QUOTE:
  .N "\""
  .DATA LIT
  QUOTE_WA: .DATA COLON
QUOTE_CA:
  .DATA STAR_HASH_WA .DATA 0x22
  .DATA STAR_SEMI_WA

S_LIT: 
; String literal
; Builds the string into the dictionary

  .X "S\""
  .DATA QUOTE
S_LIT_WA: .DATA COLON
S_LIT_CA:
  .DATA MODE_WA .DATA AT_WA
  .DATA STAR_IF_WA ; Compiling?
  .DATA S_LIT_INTERACTIVE
  .DATA STAR_HASH_WA .DATA STAR_S_LIT_WA
  .DATA COMMA_WA
  .DATA STAR_HASH_WA .DATA 0x22
  .DATA TOKEN_WA ; Move the string to the dictionary
  .DATA TOKEN_LEN_WA
  .DATA TWO_PLUS_WA
  .DATA ALIGN_WA
  .DATA DP_WA
  .DATA PLUS_STORE_WA
  .DATA STAR_ELSE_WA
  .DATA S_LIT_DONE

S_LIT_INTERACTIVE:
  .DATA VAR_LBUF_IDX_WA
  .DATA AT_WA
  .DATA TWO_MINUS_WA
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 0x22
  .DATA TOKEN_WA
  .DATA DP_AT_WA
  .DATA AT_WA
  .DATA SWAP_WA
  .DATA STORE_WA

S_LIT_DONE:
  .DATA STAR_SEMI_WA

STAR_S_LIT:
  .X "*S\""
  .DATA S_LIT
STAR_S_LIT_WA: .DATA STAR_S_LIT_CA
STAR_S_LIT_CA:
  MOV RA,RI
  LD RB,RI
  ADD RI,RB
  ADDI RI,3
  CLRI RI,0 ; Word align
  PUSH RA,SP
  JPI NEXT

QUESTION:
  .N "?"
  .DATA STAR_S_LIT
QUESTION_WA: .DATA COLON
QUESTION_CA:
  .DATA STAR_LIT_WA
  .DATA 1
  .SDATA "?"
  .DATA RESTART_WA
  .DATA STAR_SEMI_WA

TICK: ; ( -- ca )
  .N "'"
  .DATA QUESTION
TICK_WA: .DATA COLON
TICK_CA:
  .DATA ASPACE_WA
  .DATA TOKEN_WA
  .DATA SEARCH_WA
  .DATA NOT_WA 
  .DATA STAR_IF_WA
  .DATA TICK_DONE 
  .DATA QUESTION_WA
TICK_DONE:
  .DATA WA_TO_CA_WA
  .DATA STAR_SEMI_WA

N_TICK: ; ( -- na )
  .N "N'"
  .DATA TICK
N_TICK_WA: .DATA COLON
N_TICK_CA:
  .DATA ASPACE_WA
  .DATA TOKEN_WA
  .DATA SEARCH_WA
  .DATA NOT_WA 
  .DATA STAR_IF_WA
  .DATA N_TICK_DONE 
  .DATA QUESTION_WA
N_TICK_DONE:
  .DATA STAR_SEMI_WA

Q_FENCED:
; Is the WA below the current FENCE?
; ( wa -- flag )
  .N "?FENCED"
  .DATA N_TICK
Q_FENCED_WA: .DATA COLON
Q_FENCED_CA:
  .DATA CA_TO_WA_WA
  .DATA VAR_FENCE_WA .DATA AT_WA
  .DATA LTE_WA
  .DATA STAR_SEMI_WA

FORGET: 
  .N "FORGET"
  .DATA Q_FENCED
FORGET_WA: .DATA COLON
FORGET_CA:
  .DATA CURRENT_WA .DATA AT_WA .DATA CONTEXT_WA .DATA STORE_WA
  .DATA N_TICK_WA      ; Get the address of the word to forget
  .DATA DUP_WA
  .DATA VAR_FENCE_WA
  .DATA AT_WA
  .DATA GT_WA       ; Is it below the fence?
  .DATA STAR_IF_WA
  .DATA FORGET_FAIL
FORGET_OK:
  .DATA DUP_WA       ; copy it
  .DATA NEXT_WORD_WA ; address of previous word
  .DATA CURRENT_WA .DATA AT_WA
  .DATA STORE_WA     ; Reset the current vocab
  .DATA DP_WA
  .DATA STORE_WA     ; And the dictionary pointer
  .DATA STAR_ELSE_WA .DATA FORGET_DONE
FORGET_FAIL:
  .DATA STAR_LIT_WA .DATA 25
  .SDATA "Cannot forget below FENCE"
  .DATA DROP_WA
FORGET_DONE:
  .DATA STAR_SEMI_WA

STATE:
  .N "STATE"
  .DATA FORGET
STATE_WA:
  .DATA STATE_CA
STATE_CA:
  .ALIAS RA,STATE
  LDI STATE,%STATE
  PUSH STATE,SP
  JPI NEXT


BACKSLASH: ; Forth word delimiting a \ comment 
  .X "\\"
  .DATA STATE
BACKSLASH_WA: .DATA COLON
BACKSLASH_CA:
  .DATA STAR_HASH_WA
  .DATA 92 ; The backslash character
  .DATA TOKEN_WA
  .DATA STAR_SEMI_WA

PAREN: ; Forth word delimiting a ( comment )
  .X "("
  .DATA BACKSLASH
PAREN_WA: .DATA COLON
PAREN_CA:
  .DATA STAR_HASH_WA
  .DATA 41
  .DATA TOKEN_WA
  .DATA STAR_SEMI_WA

CSPLIT:
  .N "CSPLIT"
  .DATA PAREN
CSPLIT_WA: .DATA CSPLIT_CA
CSPLIT_CA:
; Split the TOS into two bytes
; ( word -- l h )
  POP RA,SP
  MOV RB,RA
  LDI R0,0x00ff
  AND RA,R0
  SRI RB,8
  PUSH RA,SP
  PUSH RB,SP
  JPI NEXT

DOT_TWO_BYTES:
  .N ".2BYTES"
  .DATA CSPLIT
DOT_TWO_BYTES_WA: .DATA COLON
DOT_TWO_BYTES_CA:
  .DATA CSPLIT_WA
  .DATA SWAP_WA
  .DATA DOT_C_WA 
  .DATA DOT_ASPACE_WA
  .DATA DOT_C_WA
  .DATA STAR_SEMI_WA 

DOT_TWO_CHARS:
  .N ".2CHARS"
  .DATA DOT_TWO_BYTES
DOT_TWO_CHARS_WA: .DATA COLON
DOT_TWO_CHARS_CA:
  .DATA CSPLIT_WA
  .DATA SWAP_WA
  .DATA DOT_ASPACE_WA
  .DATA DOT_Q_C_WA 
  .DATA DOT_ASPACE_WA 
  .DATA DOT_Q_C_WA ; and the characters
  .DATA STAR_SEMI_WA

EXPAND:
  .N "EXPAND"
  .DATA DOT_TWO_CHARS
EXPAND_WA: .DATA EXPAND_CA
EXPAND_CA:
; Patch the code so that the core vocabulary is set to point to all 
; words currently defined
; Patch the FENCE inital value also
; What's the current location?
  LDI R0,%CURRENT
  LD R1,R0
  LD R1,R1
  LDI R2,CORE_PATCH_VOCABULARY
  ST R2,R1
  LDI R2,CORE_PATCH_FENCE
  ST R2,R1
  LDI R0,CORE_PATCH_DP
  LDI R1,%DICTIONARY_POINTER
  LD R1,R1
  ST R0,R1
  JPI NEXT

VAR_FENCE:
  .N "$FENCE"
  .DATA EXPAND
VAR_FENCE_WA: .DATA VAR_FENCE_CA
VAR_FENCE_CA:
  LDI RA,%FENCE
  PUSH RA,SP
  JPI NEXT

; Set %FENCE to point ot the last word in the dictionary
CORE_VOCABULARY:
FENCE:
  .N "FENCE"
  .DATA VAR_FENCE
FENCE_WA: .DATA FENCE_CA
FENCE_CA:
  LDI R0,%CURRENT
  LD R0,R0 ; CURRENT @ @
  LD R0,R0
  LDI R1,%FENCE
  ST R1,R0
  JPI NEXT

DICTIONARY_END:
    .DATA 00
